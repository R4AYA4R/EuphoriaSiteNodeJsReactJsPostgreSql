
// если уже описали и создали таблицу в базе данных postgreSql,но потом захотели удалить у этой таблицы поле,то нужно удалить всю таблицу в pgAdmin и заново создать и отправить запрос на создания таблицы и объекта в базе данных postgreSql

import { DataTypes, STRING } from "sequelize";
import db from "../db.js";

// при создании таблиц нужно сразу описать таблицу и сразу же описать связи этих таблиц,не сохраняя еще файл,чтобы не мог пойти запрос в базу данных для содания таблицы до того,как мы описали связи таблиц,так как если описать таблицу и сохранить файл,а потом только дописать связи таблиц,то будет ошибка при попытке их связать и нужно будет удалять таблицы из базы данных вручную(выбирать при удалении Delete CASCADE,а не просто Delete,иначе не удаляется) в pgAdmin ) и потом опять они создадутся,но уже с правильными связями

// создаем сущность товара(таблицу товара в базе данных postgreSql),первым параметром у define указываем название таблицы,вторым - объект в котором описываем поля,которые будут у этой сущности(таблицы), и здесь должно быть отдельное поле для ссылки на category(категорию) и taste(вкус),то есть какие объекты из таблицы category и taste принадлежат таблице товара(Product),но мы его сейчас не указываем,оно будет подставлено автоматически с помощью sequelize,когда мы будем указывать связи этих всех таблиц
const Product = db.define('product', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, // описываем поле id,указываем тип INTEGER у DataTypes, указываем,что это первичный ключ(primaryKey:true, то есть это поле уникально и обязательно,и что оно однозначно идентифицирует каждую запись(каждый типа объект таблицы) в таблице), и что это authIncrement,чтобы с новой записью это поле автоматически увеличивалось на 1

    name: { type: DataTypes.STRING, unique: true, allowNull: false },  // указываем, что это поле уникально(unique:true),то есть другого такого же не может быть в этой таблице, и указываем этому полю еще свойство allowNull:false,то есть оно не может быть null(пустым)

    descText: { type: DataTypes.TEXT, allowNull: false }, // указываем этому полю описания для товара тип как DataTypes.TEXT,так как тип TEXT не имеет ограничение на длину символов строки,а тип STRING в Sequelize имеет ограничение символов в строке (255 символов максимум)

    price: { type: DataTypes.FLOAT, allowNull: false }, // указываем полю для цены тип DataTypes.FLOAT( float - тип данных числа с запятой(точкой),типа 0.5)

    priceDiscount: { type: DataTypes.FLOAT, allowNull: true }, // указываем этому полю allowNull как true,так как это необязательное поле для скидки товара,так как не у всех товаров будет скидка и потом будем просто проверять,есть ли это поле у товара или нет

    amount: { type: DataTypes.INTEGER, allowNull: false, defaultValue: 1 }, // указываем этому полю значение по умолчанию 1 (defaultValue:1)

    totalPrice: { type: DataTypes.FLOAT, allowNull: false },

    sizes: { type: DataTypes.ARRAY(DataTypes.STRING), allowNull: false }, // указываем поле для размеров для товара, указываем ему тип как DataTypes.ARRAY(DataTypes.STRING),то есть массив со строковыми значениями

    rating: { type: DataTypes.FLOAT, allowNull: false, defaultValue: 0 }, // указываем полю для рейтинга тип DataTypes.FLOAT( float - тип данных числа с запятой(точкой),типа 0.5) и значение по дефолту как 0

    mainImage: { type: DataTypes.STRING, allowNull: false }, // указываем этому полю для главного изображения товара тип STRING,так как там будем хранить только название файла и его расширение, указываем этому полю еще свойство allowNull:false,то есть оно не может быть null(пустым)

    descImages: { type: DataTypes.ARRAY(DataTypes.STRING), allowNull: false } // указываем этому полю для массива названий картинок описания товара тип как DataTypes.ARRAY(DataTypes.STRING),то есть массив,внутри которого будут значения с типом STRING

})

// создаем сущность(таблицу) для категории,чтобы потом связать эту таблицу с таблицей Product(товара),это не обязательно делать,так как можно было просто создать отдельное поле для категорий у объекта товара в таблице Product,но если делать такие связи таблиц,то поиск по этим связам будет быстрее(типа например,будет поле category у объекта товара,и у него будут значения не самих строк категорий,а индексов(id) объектов категорий из таблицы category,то есть это в итоге будут значения этих строк категорий,но по факту поиск по этому полю category будет как по id объектов категорий из таблицы category(типа id 1 будет связан с id 1 у объекта категории из таблицы category)),так как postgreSql использует индексы,и потом при удалении или изменении,например,категорий,то для всех объектов товаров эти категории будут автоматически переназначены,без необходимости это изменять вручную
const Category = db.define('category',{

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, // описываем поле id,указываем тип INTEGER у DataTypes, указываем,что это первичный ключ(primaryKey:true, то есть это поле уникально и обязательно,и что оно однозначно идентифицирует каждую запись(каждый типа объект таблицы) в таблице), и что это authIncrement,чтобы с новой записью это поле автоматически увеличивалось на 1

    category: {type:DataTypes.STRING, allowNull:false} // указываем поле для значения самой категории

})

// создаем сущность(таблицу) type для типа мужской или женской одежды
const Type = db.define('type',{

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, // описываем поле id,указываем тип INTEGER у DataTypes, указываем,что это первичный ключ(primaryKey:true, то есть это поле уникально и обязательно,и что оно однозначно идентифицирует каждую запись(каждый типа объект таблицы) в таблице), и что это authIncrement,чтобы с новой записью это поле автоматически увеличивалось на 1

    type: {type:DataTypes.STRING, allowNull:false} // указываем поле для значения самой категории

})

// описываем связи между таблицами, hasMany(связь 1 ко многим,типа один объект этой таблицы может иметь связь с многими объектами другой таблицы), hasOne - связь 1 к 1(один объект этой таблицы может иметь одну связь(то есть будет отдельное поле у объекта одной таблицы, в котором будет указан id объекта другой таблицы,который принадлежит этой таблице) с объектом другой таблицы)

// при создании таблиц нужно сразу описать таблицу и сразу же описать связи этих таблиц,не сохраняя еще файл,чтобы не мог пойти запрос в базу данных для содания таблицы до того,как мы описали связи таблиц,так как если описать таблицу и сохранить файл,а потом только дописать связи таблиц,то будет ошибка при попытке их связать и нужно будет удалять таблицы из базы данных вручную и потом опять они создадутся,но уже с правильными связями

// в данном случае потом при создании объекта товара в таблице Product нужно будет указать поле categoryId со значением id объекта из таблицы Category с нужной категорией,этот categoryId появляется автоматически,когда указываем связи таблиц типа hasMany и тд, обычно указывать связи таблиц нужно парами,типа hasOne и belongsTo, hasMany и belongsTo,belongsToMany и belongsToMany(эта связь многие ко многим делается через дополнительную связующую таблицу,где будут описаны поля с id объектов из этих 2 таблиц для их связи) ,чтобы лучше согласовывались данные в sequelize

// для создания отношений один-к-одному используются hasOne() и belongsTo(), для один-ко-многим — hasMany() и belongsTo(), для многие-ко-многим — два belongsToMany()

Category.hasMany(Product); // указываем,что одна запись(объект сущности(таблицы)) Category может иметь много связей с сущностью Product(с многими объектами из сущности Product),то есть у объекта из таблицы Product будет поле с ссылкой на объект из таблицы Category(в данном случае у объекта из таблицы Product будет поле categoryId,где будет значение id объекта из таблицы Category,с которым связан этот объект из Product),это касается связываний типа hasOne,hasMany

Product.belongsTo(Category); // указываем,что сущность Product принадлежит сущности Category, то есть каждый объект из таблицы Product имеет поле с id объекта из таблицы Category(то есть категорию товара), когда указываем belongsTo,то в данном случае,у объектов таблицы Product будут автоматически созданы поля categoryId для категорий,и потом будем фильтровать объекты товаров по полю categoryId со значением определенного id категории(со значением id объекта из таблицы Category,так мы будем знать,что это за категория), то есть у объекта из таблицы Product будет поле с ссылкой на объект из таблицы Category(в данном случае у объекта из таблицы Product будет поле categoryId,где будет значение id объекта из таблицы Category,с которым связан этот объект из Product),это касается связываний типа belongsTo, но при связи belongsToMany нужно указать еще объект опций с полем through(в нем указать название еще одной таблицы(ее нужно создать),которая будет связывать 2 таблицы автоматически,в этой связной таблице будут поля с id первой и второй таблицы для связи этих таблиц)


Type.hasMany(Product); // указываем,что одна запись(объект сущности(таблицы)) Type может иметь много связей с сущностью Product(с многими объектами из сущности Product),то есть у объекта из таблицы Product будет поле с ссылкой на объект из таблицы Type(в данном случае у объекта из таблицы Product будет поле typeId,где будет значение id объекта из таблицы Type,с которым связан этот объект из Product),это касается связываний типа hasOne,hasMany

Product.belongsTo(Type); // указываем,что сущность Product принадлежит сущности Type, то есть каждый объект из таблицы Product имеет поле с id объекта из таблицы Type(то есть тип для мужской или женской одежды)


// экспортируем объект с полями всех таблиц,которые мы создали
export default {
    Product,
    Category,
    Type
}