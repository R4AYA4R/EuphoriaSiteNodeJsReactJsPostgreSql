
// если уже описали и создали таблицу в базе данных postgreSql,но потом захотели удалить у этой таблицы поле,то нужно удалить всю таблицу в pgAdmin и заново создать и отправить запрос на создания таблицы и объекта в базе данных postgreSql

import { DataTypes, STRING } from "sequelize";
import db from "../db.js";

// при создании таблиц нужно сразу описать таблицу и сразу же описать связи этих таблиц,не сохраняя еще файл,чтобы не мог пойти запрос в базу данных для содания таблицы до того,как мы описали связи таблиц,так как если описать таблицу и сохранить файл,а потом только дописать связи таблиц,то будет ошибка при попытке их связать и нужно будет удалять таблицы из базы данных вручную(выбирать при удалении Delete CASCADE,а не просто Delete,иначе не удаляется) в pgAdmin ) и потом опять они создадутся,но уже с правильными связями

// создаем сущность товара(таблицу товара в базе данных postgreSql),первым параметром у define указываем название таблицы,вторым - объект в котором описываем поля,которые будут у этой сущности(таблицы), и здесь должно быть отдельное поле для ссылки на category(категорию) и taste(вкус),то есть какие объекты из таблицы category и taste принадлежат таблице товара(Product),но мы его сейчас не указываем,оно будет подставлено автоматически с помощью sequelize,когда мы будем указывать связи этих всех таблиц
const Product = db.define('product', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, // описываем поле id,указываем тип INTEGER у DataTypes, указываем,что это первичный ключ(primaryKey:true, то есть это поле уникально и обязательно,и что оно однозначно идентифицирует каждую запись(каждый типа объект таблицы) в таблице), и что это authIncrement,чтобы с новой записью это поле автоматически увеличивалось на 1

    name: { type: DataTypes.STRING, unique: true, allowNull: false },  // указываем, что это поле уникально(unique:true),то есть другого такого же не может быть в этой таблице, и указываем этому полю еще свойство allowNull:false,то есть оно не может быть null(пустым)

    descText: { type: DataTypes.TEXT, allowNull: false }, // указываем этому полю описания для товара тип как DataTypes.TEXT,так как тип TEXT не имеет ограничение на длину символов строки,а тип STRING в Sequelize имеет ограничение символов в строке (255 символов максимум)

    price: { type: DataTypes.FLOAT, allowNull: false }, // указываем полю для цены тип DataTypes.FLOAT( float - тип данных числа с запятой(точкой),типа 0.5)

    priceDiscount: { type: DataTypes.FLOAT, allowNull: true }, // указываем этому полю allowNull как true,так как это необязательное поле для скидки товара,так как не у всех товаров будет скидка и потом будем просто проверять,есть ли это поле у товара или нет

    amount: { type: DataTypes.INTEGER, allowNull: false, defaultValue: 1 }, // указываем этому полю значение по умолчанию 1 (defaultValue:1)

    totalPrice: { type: DataTypes.FLOAT, allowNull: false },

    sizes: { type: DataTypes.ARRAY(DataTypes.STRING), allowNull: false }, // указываем поле для размеров для товара, указываем ему тип как DataTypes.ARRAY(DataTypes.STRING),то есть массив со строковыми значениями

    rating: { type: DataTypes.FLOAT, allowNull: false, defaultValue: 0 }, // указываем полю для рейтинга тип DataTypes.FLOAT( float - тип данных числа с запятой(точкой),типа 0.5) и значение по дефолту как 0

    mainImage: { type: DataTypes.STRING, allowNull: false }, // указываем этому полю для главного изображения товара тип STRING,так как там будем хранить только название файла и его расширение, указываем этому полю еще свойство allowNull:false,то есть оно не может быть null(пустым)

    descImages: { type: DataTypes.ARRAY(DataTypes.STRING), allowNull: false } // указываем этому полю для массива названий картинок описания товара тип как DataTypes.ARRAY(DataTypes.STRING),то есть массив,внутри которого будут значения с типом STRING

})

// создаем сущность(таблицу) для категории,чтобы потом связать эту таблицу с таблицей Product(товара),это не обязательно делать,так как можно было просто создать отдельное поле для категорий у объекта товара в таблице Product,но если делать такие связи таблиц,то поиск по этим связам будет быстрее(типа например,будет поле category у объекта товара,и у него будут значения не самих строк категорий,а индексов(id) объектов категорий из таблицы category,то есть это в итоге будут значения этих строк категорий,но по факту поиск по этому полю category будет как по id объектов категорий из таблицы category(типа id 1 будет связан с id 1 у объекта категории из таблицы category)),так как postgreSql использует индексы,и потом при удалении или изменении,например,категорий,то для всех объектов товаров эти категории будут автоматически переназначены,без необходимости это изменять вручную
const Category = db.define('category', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, // описываем поле id,указываем тип INTEGER у DataTypes, указываем,что это первичный ключ(primaryKey:true, то есть это поле уникально и обязательно,и что оно однозначно идентифицирует каждую запись(каждый типа объект таблицы) в таблице), и что это authIncrement,чтобы с новой записью это поле автоматически увеличивалось на 1

    category: { type: DataTypes.STRING, allowNull: false } // указываем поле для значения самой категории

})

// создаем сущность(таблицу) type для типа мужской или женской одежды
const Type = db.define('type', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }, // описываем поле id,указываем тип INTEGER у DataTypes, указываем,что это первичный ключ(primaryKey:true, то есть это поле уникально и обязательно,и что оно однозначно идентифицирует каждую запись(каждый типа объект таблицы) в таблице), и что это authIncrement,чтобы с новой записью это поле автоматически увеличивалось на 1

    type: { type: DataTypes.STRING, allowNull: false } // указываем поле для значения самой категории

})

// создаем сущность (таблицу) для объекта пользователя для регистрации и авторизации
const User = db.define('user', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    email: { type: DataTypes.STRING, unique: true, allowNull: false },

    password: { type: DataTypes.STRING, allowNull: false },

    userName: { type: DataTypes.STRING, allowNull: false }

})

// создаем сущность (таблицу) для объекта роли пользователя
const Role = db.define('role', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    role: { type: DataTypes.STRING, unique: true, allowNull: false, defaultValue: "USER" }

})

// создаем сущность(таблицу) для refresh токена,эта таблица будет иметь ссылку на объект из таблицы User,это мы укажем ниже где связи таблиц
const Token = db.define('token', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    refreshToken: { type: DataTypes.STRING, allowNull: false }

})

// создаем сущность(таблицу) для объекта комментария,эта таблица будет иметь ссылку на объект из таблицы User,это мы укажем ниже где связи таблиц
const Comment = db.define('comment',{

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    name: {type:DataTypes.STRING, allowNull:false},

    text: {type:DataTypes.STRING, allowNull:false},

    rating: {type:DataTypes.FLOAT, allowNull:false},

    createdTime: {type:DataTypes.STRING, allowNull:false},

    // указываем поле adminReply для объекта ответа от админа для этого комментария,можно или указать этому полю просто,что это объект(то есть тип JSON),или создать отдельную таблицу для ответов от админа,там указать конкертные поля,которые были бы в объекте от админа и связать ее с таблицей комментариев(то есть объект ответа админа связать с объектом комментария)
    adminReply: {
        type:DataTypes.JSON,
        allowNull:true,

        // эти поля здесь не работают,так как тут можно только указать тип поля,в данном случае тип объекта adminReply,в данном случае указали ему тип JSON(DataTypes.JSON),то есть это объект,или можно было бы создать отдельную таблицу для ответов от админа,там указать конкертные поля,которые были бы в объекте от админа и связать ее с таблицей комментариев(то есть объект ответа админа связать с объектом комментария),но в данном случае,так как этот объект ответа от админа может быть null(то есть не обязательный) и это в данном случае тоже подходит,то оставили уже так
        // text:{type:DataTypes.STRING, allowNull:true}, // указываем поле для самого текста ответа от админа,указываем ему allowNull:true(то есть оно может быть необязательным),так как ответа от админа может и не быть,и это поле может быть пустым

        // createdTime:{type:DataTypes.STRING, allowNull:true}, // указываем поле,в котором будем хранить значение даты,когда создался этот комментарий,указываем ему allowNull:true(то есть оно может быть необязательным),так как ответа от админа может и не быть,и это поле может быть пустым

    }

})

// создаем сущность(таблицу) для объекта товара корзины
const CartProduct = db.define('cartProduct', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    usualProductId: {type:DataTypes.INTEGER, allowNull:false}, // указываем поле для id объекта товара из обычного каталога,потом на фронтенде будем использовать это поле,чтобы перейти на страницу товара каталога

    name: { type: DataTypes.STRING, allowNull: false },  // не указываем, что это поле уникально(unique:true),так как будем делать возможность добавлять один и тот же товар,но с разными размерами и указываем этому полю еще свойство allowNull:false,то есть оно не может быть null(пустым)

    descText: { type: DataTypes.TEXT, allowNull: false }, // указываем этому полю описания для товара тип как DataTypes.TEXT,так как тип TEXT не имеет ограничение на длину символов строки,а тип STRING в Sequelize имеет ограничение символов в строке (255 символов максимум)

    price: { type: DataTypes.FLOAT, allowNull: false }, // указываем полю для цены тип DataTypes.FLOAT( float - тип данных числа с запятой(точкой),типа 0.5)

    priceDiscount: { type: DataTypes.FLOAT, allowNull: true }, // указываем этому полю allowNull как true,так как это необязательное поле для скидки товара,так как не у всех товаров будет скидка и потом будем просто проверять,есть ли это поле у товара или нет

    amount: { type: DataTypes.INTEGER, allowNull: false, defaultValue: 1 }, // указываем этому полю значение по умолчанию 1 (defaultValue:1)

    totalPrice: { type: DataTypes.FLOAT, allowNull: false },

    size: { type: DataTypes.STRING, allowNull: false }, // указываем поле для размера для товара

    rating: { type: DataTypes.FLOAT, allowNull: false, defaultValue: 0 }, // указываем полю для рейтинга тип DataTypes.FLOAT( float - тип данных числа с запятой(точкой),типа 0.5) и значение по дефолту как 0

    mainImage: { type: DataTypes.STRING, allowNull: false }, // указываем этому полю для главного изображения товара тип STRING,так как там будем хранить только название файла и его расширение, указываем этому полю еще свойство allowNull:false,то есть оно не может быть null(пустым)

    descImages: { type: DataTypes.ARRAY(DataTypes.STRING), allowNull: false } // указываем этому полю для массива названий картинок описания товара тип как DataTypes.ARRAY(DataTypes.STRING),то есть массив,внутри которого будут значения с типом STRING


})

// создаем сущность(таблицу) для полей(текста и тд) на сайте,которые сможет изменять админ
const AdminFields = db.define('adminFields', {

    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    email: { type: DataTypes.STRING, allowNull: false } // создаем поле для почты с типом STRING и allowNull false(что это поле не может быть пустым)

})

// описываем связи между таблицами, hasMany(связь 1 ко многим,типа один объект этой таблицы может иметь связь с многими объектами другой таблицы), hasOne - связь 1 к 1(один объект этой таблицы может иметь одну связь(то есть будет отдельное поле у объекта одной таблицы, в котором будет указан id объекта другой таблицы,который принадлежит этой таблице) с объектом другой таблицы)

// при создании таблиц нужно сразу описать таблицу и сразу же описать связи этих таблиц,не сохраняя еще файл,чтобы не мог пойти запрос в базу данных для содания таблицы до того,как мы описали связи таблиц,так как если описать таблицу и сохранить файл,а потом только дописать связи таблиц,то будет ошибка при попытке их связать и нужно будет удалять таблицы из базы данных вручную и потом опять они создадутся,но уже с правильными связями

// в данном случае потом при создании объекта товара в таблице Product нужно будет указать поле categoryId со значением id объекта из таблицы Category с нужной категорией,этот categoryId появляется автоматически,когда указываем связи таблиц типа hasMany и тд, обычно указывать связи таблиц нужно парами,типа hasOne и belongsTo, hasMany и belongsTo,belongsToMany и belongsToMany(эта связь многие ко многим делается через дополнительную связующую таблицу,где будут описаны поля с id объектов из этих 2 таблиц для их связи) ,чтобы лучше согласовывались данные в sequelize

// для создания отношений один-к-одному используются hasOne() и belongsTo(), для один-ко-многим — hasMany() и belongsTo(), для многие-ко-многим — два belongsToMany()

Category.hasMany(Product); // указываем,что одна запись(объект сущности(таблицы)) Category может иметь много связей с сущностью Product(с многими объектами из сущности Product),то есть у объекта из таблицы Product будет поле с ссылкой на объект из таблицы Category(в данном случае у объекта из таблицы Product будет поле categoryId,где будет значение id объекта из таблицы Category,с которым связан этот объект из Product),это касается связываний типа hasOne,hasMany

Product.belongsTo(Category); // указываем,что сущность Product принадлежит сущности Category, то есть каждый объект из таблицы Product имеет поле с id объекта из таблицы Category(то есть категорию товара), когда указываем belongsTo,то в данном случае,у объектов таблицы Product будут автоматически созданы поля categoryId для категорий,и потом будем фильтровать объекты товаров по полю categoryId со значением определенного id категории(со значением id объекта из таблицы Category,так мы будем знать,что это за категория), то есть у объекта из таблицы Product будет поле с ссылкой на объект из таблицы Category(в данном случае у объекта из таблицы Product будет поле categoryId,где будет значение id объекта из таблицы Category,с которым связан этот объект из Product),это касается связываний типа belongsTo, но при связи belongsToMany нужно указать еще объект опций с полем through(в нем указать название еще одной таблицы(ее нужно создать),которая будет связывать 2 таблицы автоматически,в этой связной таблице будут поля с id первой и второй таблицы для связи этих таблиц)


Type.hasMany(Product); // указываем,что одна запись(объект сущности(таблицы)) Type может иметь много связей с сущностью Product(с многими объектами из сущности Product),то есть у объекта из таблицы Product будет поле с ссылкой на объект из таблицы Type(в данном случае у объекта из таблицы Product будет поле typeId,где будет значение id объекта из таблицы Type,с которым связан этот объект из Product),это касается связываний типа hasOne,hasMany

Product.belongsTo(Type); // указываем,что сущность Product принадлежит сущности Type, то есть каждый объект из таблицы Product имеет поле с id объекта из таблицы Type(то есть тип для мужской или женской одежды)


Role.hasMany(User); // указываем,что объект из таблицы Role может иметь много связей с объектами из таблицы User,но поле с ссылкой на объект из таблицы Role будет создано у объекта из таблицы User(в данном случае у объекта из таблицы User будет поле roleId,где будет указано значение id объекта из таблицы Role,с которым этот объект из таблицы User связан)

User.belongsTo(Role); // указываем,что у объекта из таблицы User будет поле с ссылкой на объект из таблицы Role(в данном случае у объекта из таблицы User будет поле roleId,где будет значение id объекта из таблицы Role,с которым связан этот объект из User),это касается связываний типа belongsTo


User.hasOne(Token); // указываем,что объект из таблицы User будет иметь одну связть с объектом из таблицы Token,но поле с ссылкой на объект из таблицы User будет создано у объекта из таблицы Token(то есть в данном случае у объекта из таблицы Token будет поле userId,где будет указано значение id объекта из таблицы User,с которым этот объект из таблицы Token связан), это касается связываний типа hasOne,hasMany

Token.belongsTo(User); // указываем,что у объекта из таблицы Token будет поле с ссылкой на объект из таблицы User(в данном случае у объекта из таблицы Token будет поле userId,где будет значение id объекта из таблицы User,с которым связан этот объект из Token),это касается связываний типа belongsTo


Product.hasMany(Comment);  // указываем,что объект из таблицы Product будет иметь много связей с объектами из таблицы Comment,но поле с ссылкой на объект из таблицы Product будет создано у объекта из таблицы Comment(то есть в данном случае у объекта из таблицы Comment будет поле productId,где будет указано значение id объекта из таблицы Product,с которым этот объект из таблицы Comment связан), это касается связываний типа hasOne,hasMany

Comment.belongsTo(Product);  // указываем,что у объекта из таблицы Comment будет поле с ссылкой на объект из таблицы Product(в данном случае у объекта из таблицы Comment будет поле productId,где будет значение id объекта из таблицы Product,с которым связан этот объект из Comment),это касается связываний типа belongsTo


User.hasMany(CartProduct); // указываем,что объект из таблицы User будет иметь много связей с объектами из таблицы CartProduct,но поле с ссылкой на объект из таблицы User будет создано у объекта из таблицы CartProduct(то есть в данном случае у объекта из таблицы CartProduct будет поле userId,где будет указано значение id объекта из таблицы User,с которым этот объект из таблицы CartProduct связан), это касается связываний типа hasOne,hasMany

CartProduct.belongsTo(User); // указываем,что у объекта из таблицы CartProduct будет поле с ссылкой на объект из таблицы User(в данном случае у объекта из таблицы CartProduct будет поле userId,где будет значение id объекта из таблицы User,с которым связан этот объект из CartProduct),это касается связываний типа belongsTo

Category.hasMany(CartProduct); // указываем,что одна запись(объект сущности(таблицы)) Category может иметь много связей с сущностью CartProduct(с многими объектами из сущности CartProduct),то есть у объекта из таблицы CartProduct будет поле с ссылкой на объект из таблицы Category(в данном случае у объекта из таблицы CartProduct будет поле categoryId,где будет значение id объекта из таблицы Category,с которым связан этот объект из CartProduct),это касается связываний типа hasOne,hasMany

CartProduct.belongsTo(Category); // указываем,что у объекта из таблицы CartProduct будет поле с ссылкой на объект из таблицы Category(в данном случае у объекта из таблицы CartProduct будет поле categoryId,где будет значение id объекта из таблицы Category,с которым связан этот объект из CartProduct),это касается связываний типа belongsTo

Type.hasMany(CartProduct); // указываем,что одна запись(объект сущности(таблицы)) Type может иметь много связей с сущностью CartProduct(с многими объектами из сущности CartProduct),то есть у объекта из таблицы CartProduct будет поле с ссылкой на объект из таблицы Type(в данном случае у объекта из таблицы CartProduct будет поле typeId,где будет значение id объекта из таблицы Type,с которым связан этот объект из CartProduct),это касается связываний типа hasOne,hasMany

CartProduct.belongsTo(Type); // указываем,что сущность CartProduct принадлежит сущности Type, то есть каждый объект из таблицы CartProduct имеет поле typeId с id объекта из таблицы Type(то есть тип для мужской или женской одежды)



// экспортируем объект с полями всех таблиц,которые мы создали
export default {
    Product,
    Category,
    Type,
    User,
    Role,
    Token,
    Comment,
    CartProduct,
    AdminFields
}