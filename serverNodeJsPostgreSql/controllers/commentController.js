
import commentService from "../service/commentService.js";
import productService from "../service/productService.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл


// создаем класс для CommentController,где будем описывать функции для эндпоинтов
class CommentController {

    // первым параметром эти функции принимают req(запрос),а вторым параметром res(ответ),третьим параметром передаем функцию next(следующий по цепочке middleware,в данном случае это наш errorMiddleware)
    async createComment(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const comment = req.body; // берем весь объект запроса со всеми полями,которые мы передали с фронтенда(не используем здесь деструктуризацию типа деструктурировать из req.body {comment} в квадратных скобках,так как просто берем все тело запроса,то есть весь объект тела запроса,а не отдельные поля)

        // оборачиваем в try catch для обработки ошибок
        try {

            const commentData = await commentService.createComment(comment);  // вызываем нашу функцию createComment из commentService,передаем туда comment(объект комментария из тела запроса),эта функция возвращает созданный комментарий в базе данных и помещаем его в переменную commentData

            return res.json(commentData); // возвращаем объект созданного комментария на клиент

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async getCommentsForProduct(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { productId, page, limit } = req.query; // берем из url(строки) запроса параметр productNameFor,чтобы получить все комментарии для конкретного товара, указываем здесь let,чтобы  можно было изменять значения этих параметров(переменных),в данном случае это надо для limit и page

        // оборачиваем в try catch для обработки ошибок
        try {

            const commentsData = await commentService.getCommentsForProduct(productId, page, limit);  // вызываем нашу функцию getCommentsForProduct из commentService,передаем туда productId(id товара из параметров запроса),эта функция возвращает объект с найденными массивами комментариев и помещаем их в переменную commentsData

            return res.json(commentsData); // возвращаем массивы найденных комментариев на клиент

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }


}

export default new CommentController(); // экспортируем объект на основе класса CommentController,чтобы потом сразу можно было после импорта этого объекта из этого файла указывать через точку функции этого класса CommentController(типа commentController.getProductsCatalog()),если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса