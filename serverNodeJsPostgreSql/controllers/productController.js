import productService from "../service/productService.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл


// создаем класс для ProductController,где будем описывать функции для эндпоинтов
class ProductController {

    // первым параметром эти функции принимают req(запрос),а вторым параметром res(ответ),третьим параметром передаем функцию next(следующий по цепочке middleware,в данном случае это наш errorMiddleware)
    async getProductsArrivals(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { limit } = req.query; // берем из параметров запроса поле limit

        // оборачиваем в try catch для обработки ошибок
        try {

            const productsData = await productService.getProductsArrivals(limit);  // вызываем нашу функцию login из userService,передаем туда email и password,эта функция возвращает refreshToken и userDto(объект пользователя с полями id,email,userName,role) и помещаем эти данные в переменную userData

            return res.json(productsData); // возвращаем массив товаров(products) на клиент

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для получения товаров для каталога
    async getProductsCatalog(req, res, next) {

        let { name, typeId, categoryId, maxPrice, minPrice, sizes, sortBy, order, page, limit } = req.query; // берем из параметров запроса поля category и тд,указываем здесь let,чтобы  можно было изменять значения этих параметров(переменных),в данном случае это надо для limit и page,также берем параметр sort(в нем будет название поля,по которому нужно сортировать,это мы передаем с фронтенда),берем поле name,чтобы искать объекты товаров по этому полю name для поиска, берем поле minPrice(минимальное значение фильтра цены) и maxPrice(максимальное значение фильтра цены),чтобы фильтровать объекты товаров по цене

        // оборачиваем в try catch для обработки ошибок
        try {

            const productsData = await productService.getProductsCatalog(name, typeId, categoryId, maxPrice, minPrice, sizes, sortBy, order, page, limit);  // вызываем нашу функцию getProductsCatalog из productService,передаем туда параметры name и тд,эта функция будет делать запрос к базе данных для получения объектов товаров каталога с фильтрами и тд и вернет объект с объектом для товаров(то есть объект products (в данном случае) и в нем будут поля count(количество объектов товаров,отфильтрованных по фильтрам типа поиску по имени и тд,но без пагинации(то есть не на отдельной странице)),и поле rows(в нем будут объекты товаров,отфильтрованные типа по поиску по имени и тд,но для конкретной страницы пагинации,то есть отфильтрованные еще по параметрам limit и offset), и полем maxPriceAllProducts(максимальная цена товара из всех товаров), помещаем этот объект в переменную productsData

            return res.json(productsData); // возвращаем на клиент объект productsData

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для получения товаров для каталога
    async getProductById(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { id } = req.params; // берем из параметров запроса поле id

        // оборачиваем в try catch для обработки ошибок
        try {

            const product = await productService.getProductById(id);  // вызываем нашу функцию getProductById из productService,передаем туда параметр id,эта функция будет делать запрос к базе данных для получения объекта товара по id и возвращает этот найденный объект товара

            return res.json(product); // возвращаем на клиент объект product

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для изменения рейтинга товара
    async updateProductRating(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { productId, rating } = req.body; // достаем(деструктуризируем) из тела запроса поля productId и rating

        // оборачиваем в try catch для обработки ошибок
        try {

            const product = await productService.updateProductRating(productId, rating);  // вызываем нашу функцию updateProductRating из productService,передаем туда параметры productId и rating,эта функция будет делать запрос к базе данных для изменения рейтинга у объекта товара по id и возвращает этот измененный объект товара

            return res.json(product); // возвращаем на клиент измененный объект product

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для добавления товара в корзину
    async addProductToCart(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const productCart = req.body; // берем весь объект запроса со всеми полями,которые мы передали с фронтенда(не используем здесь деструктуризацию типа деструктурировать из req.body {productCart} в квадратных скобках,так как просто берем все тело запроса,то есть весь объект тела запроса,а не отдельные поля) 

        // оборачиваем в try catch для обработки ошибок
        try {

            const productCreated = await productService.addProductToCart(productCart);  // вызываем нашу функцию addProductToCart из productService,передаем туда параметр product(объект товара корзины из тела запроса),эта функция будет делать запрос к базе данных для создания объекта товара корзины в базе данных и возвращает этот созданный объект товара корзины

            return res.json(productCreated); // возвращаем на клиент созданный объект товара корзины productCreated

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для получения товаров корзины
    async getAllProductsCart(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        let { userId, page, limit } = req.query; // берем из url(строки) запроса параметр userId,чтобы получить все товары корзины для определенного авторизованного пользователя,также page и limit для пагинации

        // оборачиваем в try catch для обработки ошибок
        try {

            const productsCart = await productService.getAllProductsCart(userId, page, limit);  // вызываем нашу функцию getAllProductsCart из productService,передаем туда параметры userId, page, limit,эта функция будет делать запрос к базе данных для получения объектов товаров корзины в базе данных и возвращает объект с найденными массивами объектов товаров корзины,помещаем этот объект с найденными массивами объектов товаров корзины в переменную productsCart

            return res.json(productsCart); // возвращаем массивы найденных товаров корзины на клиент

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для обновления товара корзины
    async updateProductCart(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const productCart = req.body; // достаем(деструктуризируем) из тела запроса весь объект запроса со всеми полями,которые мы передали с фронтенда(не используем здесь деструктуризацию типа деструктурировать из req.body {productCart} в квадратных скобках,так как просто берем все тело запроса,то есть весь объект тела запроса,а не отдельные поля)

        // оборачиваем в try catch для обработки ошибок
        try {

            const productCartData = await productService.updateProductCart(productCart);  // вызываем нашу функцию updateProductCart из productService,передаем туда параметр productCart,эта функция будет делать запрос к базе данных для обновления товара корзины в базе данных и возвращает объект с обновленным товаром корзины,или же строку с сообщением(если пользователь не изменил данные товара на фронтенде),помещаем этот объект с обновленным товаром корзины или же строку с сообщением в переменную productCartData

            console.log(productCartData);

            return res.json(productCartData); // возвращаем массивы найденных товаров корзины на клиент

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для удаления товара корзины
    async deleteProductCart(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { productId } = req.params; // берем productId из параметров запроса(мы указали этот динамический параметр productId в url к эндпоинту,поэтому можем его взять из req.params)

        // оборачиваем в try catch для обработки ошибок
        try {

            const productCartDeletedData = await productService.deleteProductCart(productId);  // вызываем нашу функцию deleteProductCart из productService,передаем туда параметр productId,эта функция будет делать запрос к базе данных для удаления товара корзины в базе данных и возвращает объект с удаленным товаром корзины,помещаем этот объект с удаленным товаром корзины productCartDeletedData

            console.log(productCartDeletedData);

            return res.json(productCartDeletedData); // возвращаем удаленный объект товара корзины на клиент

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // создаем функцию для изменения рейтинга товара корзины
    async updateProductCartRating(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { productId, rating } = req.body; // достаем(деструктуризируем) из тела запроса поля productId и rating

        // оборачиваем в try catch для обработки ошибок
        try {

            const productsCart = await productService.updateProductCartRating(productId, rating);  // вызываем нашу функцию updateProductCartRating из productService,передаем туда параметры productId и rating,эта функция будет делать запрос к базе данных для изменения рейтинга у объектов товаров корзины по usualProductId и возвращает этот найденный массив объектов товаров корзины

            return res.json(productsCart); // возвращаем на клиент этот найденный массив объектов товаров корзины

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    // функция для создания нового товара каталога
    async createNewProductCatalog(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProductById) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const productCatalog = req.body; // берем весь объект тела запроса и помещаем его в переменную productCatalog

        // оборачиваем в try catch для обработки ошибок
        try {

            const newProductCatalog = await productService.createNewProductCatalog(productCatalog);  // вызываем нашу функцию createNewProductCatalog из productService,передаем туда параметр productCatalog,эта функция для создания нового товара в базе данных и возвращает этот новый созданный объект товара в базе данных

            return res.json(newProductCatalog); // возвращаем на клиент этот новый созданный объект товара в базе данных

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

}

export default new ProductController(); // экспортируем объект на основе класса ProductController,чтобы потом сразу можно было после импорта этого объекта из этого файла указывать через точку функции этого класса ProductController(типа productController.getProductsCatalog()),если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса