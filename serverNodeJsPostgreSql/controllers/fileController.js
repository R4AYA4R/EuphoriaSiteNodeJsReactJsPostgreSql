
import { validationResult } from "express-validator";
import ApiError from "../exceptions/ApiError.js"; // указываем здесь вручную расширения файла .js,иначе выдает ошибку,что не может найти файл
import fileService from "../service/fileService.js";



// создаем класс для FileController,где будем описывать функции для эндпоинтов
class FileController {

    async uploadFile(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const image = req.files.image; // помещаем в переменную image сам файл (в данном случае файл картинки, но так можно и с любым файлом делать) под названием image(который мы указали в formData на фронтенде),у files у req(запроса)

        // оборачиваем в try catch для обработки ошибок
        try {

            const filePath = await fileService.uploadFile(image); // вызываем нашу функцию uploadFile в fileService и туда передаем параметр image и в переменную filePath помещаем путь до картинки в папке checkStatic

            return res.json({ name: image.name, path: filePath, file: image }); // возвращаем на фронтенд объект с полями информации о файле

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async deleteImage(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { imageName } = req.params; // берем imageName из параметров запроса(мы указали этот динамический параметр imageName в url к эндпоинту,поэтому можем его взять из req.params)

        // оборачиваем в try catch для обработки ошибок
        try {

            const deletedFilePath = await fileService.deleteImage(imageName); // вызываем нашу функцию deleteMainImage в fileService и туда передаем параметр imageName и в переменную filePath помещаем путь до картинки(которую удалили) в папке checkStatic

            return res.json({ message:'Successfully deleted', deletedFilePath }); // возвращаем на клиент объект с сообщением и с путем картинки,по которому ее удалили

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async deleteCheckStatic(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        // оборачиваем в try catch для обработки ошибок
        try {

            const messageDeleted = await fileService.deleteCheckStatic(); // вызываем нашу функцию deleteCheckStatic в fileService и в переменную messageDeleted помещаем строку,типа сообщение,что успешно удалено,его и будем передавать на фронтенд

            return res.json({ messageDeleted }); // возвращаем на клиент объект с сообщением

        } catch (e) {

            next(e);  // вызываем функцию next()(параметр этой функции getProductsArrivals) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProductsArrivals,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

}

export default new FileController(); // экспортируем объект на основе класса FileController,чтобы потом сразу можно было после импорта этого объекта из этого файла указывать через точку функции этого класса FileController(типа fileController.uploadFile()),если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса