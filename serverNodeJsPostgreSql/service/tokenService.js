
import jwt from 'jsonwebtoken'; // импортируем jwt для работы с jwt токенами,в данном случае импортируем вручную,так как автоматически не импортируется
import models from '../models/models.js'; // указываем тут расширение файла как .js вручную,иначе не находит файл

// создаем класс TokenService,где будем описывать функции для эндпоинтов для сервиса пользователей(их добавление,регистрацию и тд)
class TokenService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    // создаем функцию,которая будет генерировать пару токенов,access и refresh токены,в параметре принимает payload,данные,которые будем прятать в токен
    generateTokens(payload) {

        const accessToken = jwt.sign(payload, process.env.JWT_ACCESS_SECRET, { expiresIn: "10s" }); // вызываем функцию sign у jwt,она создает access токен,передаем первым параметром payload(данные,которые будут помещены в токен),а вторым параметром передаем секретный ключ(это любая рандомная строка,только чтобы ее никто не знал,в данном случае вынесли секретный ключ в файл .env в переменную окружения),третьим параметром передаем объект опций для генерации токена,указываем поле expiresIn:'30m'(это сколько будет жить токен,в данном случае указываем,что он будет действителен в течении 30 мин),для теста можно указать время жизни access токена 5s(секунд) и refresh токена 10s(секунд),тогда когда access токен истечет,будет повторный запрос на /refresh и обновление access токена,но после 10s когда истечет refresh токен(и до этого не было запросов на обновление access и refresh токена),уже будут недоступны функции,которые доступны авторизованным пользователям(потому что уже истечет refresh токен и пользователь будет не авторизован) и пользователя выкинет из аккаунта после обновления страницы

        console.log(accessToken);

        const refreshToken = jwt.sign(payload, process.env.JWT_REFRESH_SECRET, { expiresIn: "20s" }); // создаем refreshToken,также как и accessToken,только секретный ключ для refresh токена указываем другой и время жизни токена 30d(30 дней),чтобы если пользователь не заходил на сайт 30 дней,ему придется заново логиниться

        // возвращаем объект с полями accessToken и refreshToken
        return {
            accessToken,
            refreshToken
        }

    }

    // создаем функцию для сохранения refreshToken в базу данных,передаем в параметрах userId(id пользователя) и сам refreshToken
    async saveToken(userId, refreshToken) {

        const tokenData = await models.Token.findOne({ where: { userId } }); // ищем в базе данных токен по такому userId(как и параметр userId этой функции saveToken) и помещаем найденный объект в переменную tokenData(если вообще был найден такой объект),в поле userId у объекта из таблицы Token находится значение id объекта пользователя,с которым связан этот объект токена

        // если tokenData true,то есть если токен у этого userId уже есть
        if (tokenData) {

            tokenData.refreshToken = refreshToken;  // изменяем поле refreshToken у найденного объекта по такому userId на refreshToken который мы передадим в параметре этой функции saveToken

            return tokenData.save();  // возвращаем и сохраняем объект tokenData в базу данных, save() - сохраняем объект tokenData в базу данных,то есть сохраняем наш новый refreshToken у этого объекта, здесь используем функцию save(),а не update(),при методе save() идет 2 запроса в базу данных select(на выборку этого объекта,чтобы потом заменить ему данные) запрос и update(на изменение данных объекта) запрос,а при методе update() идет только 1 запрос на обновление данных этого объекта,save() метод нужен,чтобы убедиться,что другие поля соответсвуют изменениям или при получении данных с внешних источников

        }

        // если токен по такому userId не был найден,то скорее всего пользователь логинится первый раз,то создаем новый объект в базе данных с рефреш токеном и userId
        const token = await models.Token.create({ userId, refreshToken }); // создаем объект в базе данных с полями userId и рефреш токеном,который передадим этой функции saveToken,помещаем созданный объект в переменную token

        return token; // возвращаем созданный объект token

    }


}

export default new TokenService(); // экспортируем уже объект на основе нашего класса TokenService