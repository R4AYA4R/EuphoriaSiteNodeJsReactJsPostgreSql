
import jwt from 'jsonwebtoken'; // импортируем jwt для работы с jwt токенами,в данном случае импортируем вручную,так как автоматически не импортируется
import models from '../models/models.js'; // указываем тут расширение файла как .js вручную,иначе не находит файл

// создаем класс TokenService,где будем описывать функции для эндпоинтов для сервиса пользователей(их добавление,регистрацию и тд)
class TokenService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    // создаем функцию,которая будет генерировать пару токенов,access и refresh токены,в параметре принимает payload,данные,которые будем прятать в токен
    generateTokens(payload) {

        const accessToken = jwt.sign(payload, process.env.JWT_ACCESS_SECRET, { expiresIn: "10s" }); // вызываем функцию sign у jwt,она создает access токен,передаем первым параметром payload(данные,которые будут помещены в токен),а вторым параметром передаем секретный ключ(это любая рандомная строка,только чтобы ее никто не знал,в данном случае вынесли секретный ключ в файл .env в переменную окружения),третьим параметром передаем объект опций для генерации токена,указываем поле expiresIn:'30m'(это сколько будет жить токен,в данном случае указываем,что он будет действителен в течении 30 мин),для теста можно указать время жизни access токена 5s(секунд) и refresh токена 10s(секунд),тогда когда access токен истечет,будет повторный запрос на /refresh и обновление access токена,но после 10s когда истечет refresh токен(и до этого не было запросов на обновление access и refresh токена),уже будут недоступны функции,которые доступны авторизованным пользователям(потому что уже истечет refresh токен и пользователь будет не авторизован) и пользователя выкинет из аккаунта после обновления страницы

        console.log(accessToken);

        const refreshToken = jwt.sign(payload, process.env.JWT_REFRESH_SECRET, { expiresIn: "20s" }); // создаем refreshToken,также как и accessToken,только секретный ключ для refresh токена указываем другой и время жизни токена 30d(30 дней),чтобы если пользователь не заходил на сайт 30 дней,ему придется заново логиниться

        // возвращаем объект с полями accessToken и refreshToken
        return {
            accessToken,
            refreshToken
        }

    }

    // создаем функцию для сохранения refreshToken в базу данных,передаем в параметрах userId(id пользователя) и сам refreshToken
    async saveToken(userId, refreshToken) {

        const tokenData = await models.Token.findOne({ where: { userId } }); // ищем в базе данных токен по такому userId(как и параметр userId этой функции saveToken) и помещаем найденный объект в переменную tokenData(если вообще был найден такой объект),в поле userId у объекта из таблицы Token находится значение id объекта пользователя,с которым связан этот объект токена

        // если tokenData true,то есть если токен у этого userId уже есть
        if (tokenData) {

            tokenData.refreshToken = refreshToken;  // изменяем поле refreshToken у найденного объекта по такому userId на refreshToken который мы передадим в параметре этой функции saveToken

            return tokenData.save();  // возвращаем и сохраняем объект tokenData в базу данных, save() - сохраняем объект tokenData в базу данных,то есть сохраняем наш новый refreshToken у этого объекта, здесь используем функцию save(),а не update(),при методе save() идет 2 запроса в базу данных select(на выборку этого объекта,чтобы потом заменить ему данные) запрос и update(на изменение данных объекта) запрос,а при методе update() идет только 1 запрос на обновление данных этого объекта,save() метод нужен,чтобы убедиться,что другие поля соответсвуют изменениям или при получении данных с внешних источников

        }

        // если токен по такому userId не был найден,то скорее всего пользователь логинится первый раз,то создаем новый объект в базе данных с рефреш токеном и userId
        const token = await models.Token.create({ userId, refreshToken }); // создаем объект в базе данных с полями userId и рефреш токеном,который передадим этой функции saveToken,помещаем созданный объект в переменную token

        return token; // возвращаем созданный объект token

    }

    // создаем функцию для проверки refresh токена,не иссяк ли у него срок годности и тд
    validateRefreshToken(refreshToken) {

        try {

            const userData = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET); // верифицируем токен(декодируем его,то есть достаем из него данные payload,которые положили в него при его создании,а также проверяем,иссяк ли у него срок годности или нет),используя функцию verify(),первым параметром передаем сам токен,а вторым секретный ключ,который указывали при создании этого токена(берем его в данном случае из переменных окружения)

            return userData;  // возвращаем userData(данные,которые получили при верификации этого токена,если она была успешна(если текущий refresh токен пользователя иссяк(уже не годен по сроку годности),то будет ошибка и эта наша функция validateRefreshToken вернет null),то есть данные о пользователе,которые мы передевали в refresh токен при его создании(объект с полями userName,email,id,role))

        } catch (e) {

            // если при верификации токена была ошибка(например,если иссяк срок годности этого токена и тд),то возвращаем null
            return null;

        }


    }

    // создаем функцию для проверки access токена,не иссяк ли у него срок годности и тд,эта функция для валидации accessToken
    validateAccessToken(token) {

        try {

            const userData = jwt.verify(token, process.env.JWT_ACCESS_SECRET); // верифицируем токен(декодируем его,то есть достаем из него данные payload,которые положили в него при его создании,а также проверяем,иссяк ли у него срок годности или нет),используя функцию verify(),первым параметром передаем сам токен,а вторым секретный ключ,который указывали при создании этого токена(берем его в данном случае из переменных окружения)

            return userData;  // возвращаем userData(данные,которые получили при верификации этого токена,если она была успешна(если текущий access токен пользователя иссяк(уже не годен по сроку годности),то будет ошибка и эта наша функция validateAccessToken вернет null),то есть данные о пользователе,которые мы передевали в access токен при его создании(объект с полями userName,email,id,role))

        } catch (e) {

            // если при верификации токена была ошибка(например,если иссяк срок годности этого токена и тд),то возвращаем null
            return null;

        }


    }

    async findToken(refreshToken) {

        const tokenData = await models.Token.findOne({ where: { refreshToken } });  // вызываем функцию findOne() у таблицы Token в базе данных,передаем туда объект с полем refreshToken и условием,то есть будет найден объект с полем refreshToken и значением таким же,как и параметр этой функции findToken и этот найденный объект помещаем в переменную tokenData

        return tokenData; // возвращаем tokenData

    }

    async removeToken(refreshToken) {

        const tokenData = await models.Token.destroy({ where: { refreshToken } });  // вызываем функцию destroy() у таблицы Token в базе данных,передаем туда объект с полем refreshToken и условием,то есть будет найден объект с полем refreshToken и значением таким же,как и параметр этой функции removeToken, и этот объект будет удален из базы данных, в данном случае возвращается не сам удаленный объект токена из базы данных, а просто цифра 1,типа был удален объект) и эту цифру 1(в данном случае) помещаем в переменную tokenData

        return tokenData; // возвращаем tokenData

    }


}

export default new TokenService(); // экспортируем уже объект на основе нашего класса TokenService,чтобы можно было вызывать эти функции в этом классе через точку(типа tokenService.generateTokens()),просто импортировав файл tokenService,если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса