
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл
import ApiError from "../exceptions/ApiError.js";

import bcrypt from 'bcrypt'; // импортируем bcrypt для хеширования пароля(в данном случае импортируем вручную,иначе автоматически не импортируется)
import UserDto from "../dtos/userDto.js";
import tokenService from "./tokenService.js";

// создаем класс UserService,где будем описывать функции для эндпоинтов для сервиса пользователей(их добавление,регистрацию и тд)
class UserService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    // функция регистрации,принимает в параметрах email,userName, и password(которые мы будем получать в теле запроса)
    async registration(email, password, userName) {

        const candidate = await models.User.findOne({ where: { email } }); // ищем один объект в таблице User в базе данных с помощью функции findOne(),передаем условие,что нужно найти объект с полем email как параметр запроса email, и помещаем результат функции findOne(то есть найденный объект с таким же значением в поле email,если он был найден) в переменную candidate

        // если candidate true(то есть переменная candidate есть и в ней есть какое-то не пустое(не null) значение),то есть такой пользователь с таким email уже есть в базе данных
        if (candidate) {

            throw ApiError.BadRequest(`User with email ${email} already exists`);  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        const hashPassword = await bcrypt.hash(password, 3); // хешируем пароль с помощью функции hash() у bcrypt,первым параметром передаем пароль,а вторым - соль,степень хеширования(чем больше - тем лучше захешируется,но не нужно слишком большое число,иначе будет долго хешироваться пароль)

        const userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением USER и помещаем его в переменную userRole

        const user = await models.User.create({ email, password: hashPassword, userName, roleId: userRole.id }); // создаем объект с полями email и password в базу данных и помещаем этот объект в переменную user,в поле password помещаем значение из переменной hashPassword,то есть уже захешированный пароль,и указываем в объекте еще поле userName,в поле roleId передаем значение значение роли,которое мы получили из базы данных выше(то есть передаем в поле roleId id объекта из таблицы Role,у которого поле role равно "USER"(мы поместили этот найденный объект в переменную userRole),то есть таким образом указываем пользователю роль "USER")

        const userDto = new UserDto({ ...user, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user(который мы создали в базе данных,в коде выше) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        console.log(userDto);

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken);  // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }


    }


}

export default new UserService(); // экспортируем уже объект на основе нашего класса UserService