
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл
import ApiError from "../exceptions/ApiError.js";

import bcrypt from 'bcrypt'; // импортируем bcrypt для хеширования пароля(в данном случае импортируем вручную,иначе автоматически не импортируется)
import UserDto from "../dtos/userDto.js";
import tokenService from "./tokenService.js";

// создаем класс UserService,где будем описывать функции для эндпоинтов для сервиса пользователей(их добавление,регистрацию и тд)
class UserService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    // функция регистрации,принимает в параметрах email,userName, и password(которые мы будем получать в теле запроса)
    async registration(email, password, userName) {

        const candidate = await models.User.findOne({ where: { email } }); // ищем один объект в таблице User в базе данных с помощью функции findOne(),передаем условие,что нужно найти объект с полем email как параметр запроса email, и помещаем результат функции findOne(то есть найденный объект с таким же значением в поле email,если он был найден) в переменную candidate

        // если candidate true(то есть переменная candidate есть и в ней есть какое-то не пустое(не null) значение),то есть такой пользователь с таким email уже есть в базе данных
        if (candidate) {

            throw ApiError.BadRequest(`User with email ${email} already exists`);  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        const hashPassword = await bcrypt.hash(password, 3); // хешируем пароль с помощью функции hash() у bcrypt,первым параметром передаем пароль,а вторым - соль,степень хеширования(чем больше - тем лучше захешируется,но не нужно слишком большое число,иначе будет долго хешироваться пароль)

        const userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением USER и помещаем его в переменную userRole

        const user = await models.User.create({ email, password: hashPassword, userName, roleId: userRole.id }); // создаем объект с полями email и password в базу данных и помещаем этот объект в переменную user,в поле password помещаем значение из переменной hashPassword,то есть уже захешированный пароль,и указываем в объекте еще поле userName,в поле roleId передаем значение значение роли,которое мы получили из базы данных выше(то есть передаем в поле roleId id объекта из таблицы Role,у которого поле role равно "USER"(мы поместили этот найденный объект в переменную userRole),то есть таким образом указываем пользователю роль "USER")

        console.log(user);

        const userDto = new UserDto({ ...user.dataValues, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user.dataValues(который мы создали в базе данных,в коде выше,разворачиваем именно так из dataValues,так как сам объект user(созданный в базе данных) имеет много разных полей и вложенных объектов,а сами конкретные поля для модели user(для пользователя,типа id,userName и тд) они хранятся в этом объекте user в поле dataValues,если разворачивать просто user(...user),то будет выдавать ошибку,что не может найти нужные поля для UserDto(типа id,userName,email и тд)) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole,так как в postgreSql сделали такие связи таблиц с id)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        console.log(userDto);

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken);  // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }


    }

    async login(email, password) {

        const user = await models.User.findOne({ where: { email } }); // ищем в базе данных объект с полем email и значением как параметр email этой функции login,то есть проверяем,зарегестрирован ли пользователь вообще,и помещаем найденный(если он найден) объект в переменную user

        // если user false(или null, или другое типа пустое или false значение(undefined,0,"",NaN)),то есть такой пользователь не найден
        if (!user) {

            throw ApiError.BadRequest('User with email not found');  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        console.log(user);

        const isPassEquals = await bcrypt.compare(password, user.password); // сравниваем пароль,который отправил пользователь с захешированным паролем в базе данных,используем функцию compare() у bcrypt,передаем туда первым параметром пароль,который пользователь отправил(параметр этой функции login),а вторым параметром передаем пароль из базы данных(то есть пароль,который есть у объекта user(мы его нашли в переменной user по email),в данном случае не надо указывать user.dataValues.password(это можно указать,но сильного отличия между user.password не будет,это будет и так работать,но если указать user.password,то тогда получим еще кроме самого поля password еще и дополнительные объекты sequelize,связанные с этим объектом user),а сразу можно указать user.password,так как и так находит поле password у user,но в userDto когда нужно развернуть объект user,нужно его указать ...user.dataValues,иначе не разворачивает поля конкретно объекта пользователя user,так как по дефолту при нахождении объекта в базе данных sequelize оборачивает объекты из базы данных в свою обертку,добавляя туда другие объекты,и предыдущее состояние конкретного объекта,а уже конкретные поля объекта хранит в dataValues)

        // если isPassEquals false(или null, или другое типа пустое или false значение(undefined,0,"",NaN)),то есть пароли не одинаковы
        if (!isPassEquals) {

            throw ApiError.BadRequest('Wrong password');  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        let userRole; // указываем переменную для объекта роли пользователя,чтобы изменять ей значение потом

        // если user.roleId равно 2(в данном случае сделали так,что объект роли админа будет с id 2),то находим объект роли админа
        if (user.roleId === 2) {

            userRole = await models.Role.findOne({ where: { role: "ADMIN" } });  // находим объект роли в базе данных со значением ADMIN и помещаем его в переменную userRole

        } else {
            // в другом случае,если roleId у объекта user не равно 2(в данном случае у нас есть еще только объект роли пользователя "USER" с id 1),то находим объект роли пользователя("USER")

            userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением ADMIN и помещаем его в переменную userRole

        }

        const userDto = new UserDto({ ...user.dataValues, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user.dataValues(который мы создали в базе данных,в коде выше,разворачиваем именно так из dataValues,так как сам объект user(созданный в базе данных) имеет много разных полей и вложенных объектов,а сами конкретные поля для модели user(для пользователя,типа id,userName и тд) они хранятся в этом объекте user в поле dataValues,если разворачивать просто user(...user),то будет выдавать ошибку,что не может найти нужные поля для UserDto(типа id,userName,email и тд)) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole,так как в postgreSql сделали такие связи таблиц с id)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        console.log(userDto);

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken);  // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }


    }

    async refresh(refreshToken) {

        // если refreshToken false(или null, или другое типа пустое или false значение(undefined,0,"",NaN)),то есть его нету
        if (!refreshToken) {

            throw ApiError.UnauthorizedError();  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию UnauthorizedError,этот объект ошибки из функции UnauthorizedError попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением,если у пользователя токена нет,то он и не авторизован

        }

        const userData = tokenService.validateRefreshToken(refreshToken);  // вызываем нашу функцию validateRefreshToken(),передаем туда refreshToken,помещаем в переменную userData,payload данные(данные,которые мы помещали в токен,id пользователя и тд),которые верифицировали с помощью jwt.verify() в нашей фукнции validateRefreshToken(),если будет ошибка при верификации токена в нашей функции validateRefreshToken(),то будет возвращен null(это мы прописали в нашей функции validateRefreshToken())

        const tokenFromDb = await tokenService.findToken(refreshToken); // ищем такой токен в базе данных,помещаем найденный токен в переменную tokenFromDb,используя нашу функцию findToken(),куда передаем в параметре refreshToken

        // если userData false(или null) или tokenFromDb false(или null),то есть пользователь не авторизован
        if (!userData || !tokenFromDb) {

            throw ApiError.UnauthorizedError();  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию UnauthorizedError,этот объект ошибки из функции UnauthorizedError попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением,если у пользователя токена нет,то он и не авторизован

        }

        const user = await models.User.findOne({ where: { id: userData.id } }); // находим пользователя по id,который равен id у userData(то есть данные о пользователе,которые мы верефицировали из refresh токена выше в коде),который верифицировали из токена выше в коде с помощью нашей функции validateRefreshToken()

        let userRole; // указываем переменную для объекта роли пользователя,чтобы изменять ей значение потом

        // если user.roleId равно 2(в данном случае сделали так,что объект роли админа будет с id 2),то находим объект роли админа
        if (user.roleId === 2) {

            userRole = await models.Role.findOne({ where: { role: "ADMIN" } });  // находим объект роли в базе данных со значением ADMIN и помещаем его в переменную userRole

        } else {
            // в другом случае,если roleId у объекта user не равно 2(в данном случае у нас есть еще только объект роли пользователя "USER" с id 1),то находим объект роли пользователя("USER")

            userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением ADMIN и помещаем его в переменную userRole

        }

        const userDto = new UserDto({ ...user.dataValues, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user.dataValues(который мы создали в базе данных,в коде выше,разворачиваем именно так из dataValues,так как сам объект user(созданный в базе данных) имеет много разных полей и вложенных объектов,а сами конкретные поля для модели user(для пользователя,типа id,userName и тд) они хранятся в этом объекте user в поле dataValues,если разворачивать просто user(...user),то будет выдавать ошибку,что не может найти нужные поля для UserDto(типа id,userName,email и тд)) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole,так как в postgreSql сделали такие связи таблиц с id)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        console.log(userDto);

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken);  // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }


    }

    // функция для выхода из аккаунта,параметром принимает refreshToken 
    async logout(refreshToken) {

        const token = await tokenService.removeToken(refreshToken); // удаляем refreshToken из базы данных,вызывая нашу функцию removeToken(),передавая в параметре refreshToken

        return token; // возвращаем токен(в данном случае это будет удаленный объект из базы данных с таким значением refreshToken как и в параметре этой функции logout, но в данном случае возвращается не сам удаленный объект токена из базы данных, а просто цифра 1,типа был удален объект)


    }

    // функция для изменения данных пользователя в базе данных
    async changeAccInfo(userId, name, email, errors) {

        const user = await models.User.findOne({ where: { id: userId } }); // находим объект пользователя по id,который передали с фронтенда

        // если user false,то есть такой пользователь не найден
        if (!user) {

            throw ApiError.BadRequest('This user is not found'); // бросаем ошибку

        }

        // если параметр name (который мы взяли с фронтенда) true,то есть в name есть какое-то значение(это значение name мы на фронтенде отфильтровали по пробелам,то есть убрали из него пробелы,чтобы нельзя было просто ввести пробел как новое имя),то изменяем его у пользователя
        if (name) {

            // если name.length < 3(если параметр name,то есть новое имя пользователя,которое мы взяли с фронтенда, по количеству символов меньше трех) или name.length > 20,то показываем ошибку,в другом случае изменяем имя пользователя
            if (name.length < 3 || name.length > 20) {

                throw ApiError.BadRequest('Name must be 3 - 20 characters'); // бросаем ошибку

            } else {

                user.userName = name; // изменяем поле userName у user(объект пользователя) на name,который передали с фронтенда

                await user.save(); // сохраняем объект пользователя в базе данных

            }

        }

        // если параметр email (который мы взяли с фронтенда) true,то есть в email есть какое-то значение,то изменяем его у пользователя
        if (email) {

            const userEmailFounded = await models.User.findOne({ where: { email } }); // ищем пользователя в базе данных,у которого поле email равно параметру email,который мы передали с фронтенда(то есть новому email,на который пользователь хочет изменить),если такой пользователь не будет найден,то переменная userEmailFounded будет равна null

            // если errors.isEmpty() false,то есть массив ошибок не пустой,этот параметр errors мы передали в эту функцию changeAccInfo из userController(этот параметр errors является результатом валидации поля email с помощью валидатора body(то есть если есть ошибки при валидации поля email,то показываем ошибку),это мы прописывали у эндпоинта /changeAccInfo)
            if (!errors.isEmpty()) {

                throw ApiError.BadRequest('Enter email correctly', errors.array()); // бросаем ошибку и в нашу функцию BadRequest() передаем сообщение для ошибки и массив ошибок,полученных при валидации с помощью errors.array()

            } else if (userEmailFounded) {
                // если userEmailFounded true,то есть такой пользователь с такой почтой,которую пользователь хочет сделать, уже найден,то показываем ошибку,что такая почта уже существует
                throw ApiError.BadRequest('This email already exists');

            } else if (email.length < 3 || email.length > 30) {
                // в другом случае если email.length(длина новой почты) меньше 3 или email.length(длина новой почты) больше 30,то показываем ошибку
                throw ApiError.BadRequest('Email must be 3 - 30 characters');

            } else {

                user.email = email; // изменяем поле email у user(объект пользователя) на email,который передали с фронтенда

                await user.save(); // сохраняем объект пользователя в базе данных  

            }

        }

        console.log(user);

        const userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением USER и помещаем его в переменную userRole

        const userDto = new UserDto({ ...user.dataValues, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user.dataValues(который мы создали в базе данных,в коде выше,разворачиваем именно так из dataValues,так как сам объект user(созданный в базе данных) имеет много разных полей и вложенных объектов,а сами конкретные поля для модели user(для пользователя,типа id,userName и тд) они хранятся в этом объекте user в поле dataValues,если разворачивать просто user(...user),то будет выдавать ошибку,что не может найти нужные поля для UserDto(типа id,userName,email и тд)) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole,так как в postgreSql сделали такие связи таблиц с id)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        return userDto; // в данном случае возвращаем уже обновленный объект пользователя (userDto, только с определенными полями,не всеми,которые есть в базе данных)


    }

    // функция для изменения пароля пользователя в базе данных
    async changeAccPass(userId, currentPass, newPass) {

        const user = await models.User.findOne({ where: { id: userId } }); // находим объект пользователя по id,который передали с фронтенда

        const isEqualPass = await bcrypt.compare(currentPass, user.password); // сравниваем пароль,который отправил пользователь с захешированным паролем в базе данных,используем функцию compare() у bcrypt,передаем туда первым параметром пароль,который пользователь отправил(параметр currentPass этой функции changePass),а вторым параметром передаем пароль из базы данных(то есть захешированный пароль,который есть у объекта user(мы его нашли в переменной user по userId))

        // если isEqualPass false,то есть пароли не одинаковы
        if (!isEqualPass) {

            throw ApiError.BadRequest('Wrong current password'); // бросаем ошибку с помощью нашего ApiError,указываем у него функцию BadRequest и передаем туда сообщение

        }

        const newHashPassword = await bcrypt.hash(newPass, 3);  // хешируем пароль с помощью функции hash() у bcrypt,первым параметром передаем пароль,а вторым - соль,степень хеширования(чем больше - тем лучше захешируется,но не нужно слишком большое число,иначе будет долго хешироваться пароль)

        user.password = newHashPassword;  // изменяем поле password у объекта user,то есть меняем пароль пользователя на новый захешированный пароль в переменной newHashPassword

        await user.save();  // сохраняем объект пользователя в базе данных,чтобы в данном случае сохранился новый пароль пользователя

        console.log(user);

        const userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением USER и помещаем его в переменную userRole

        const userDto = new UserDto({ ...user.dataValues, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user.dataValues(который мы создали в базе данных,в коде выше,разворачиваем именно так из dataValues,так как сам объект user(созданный в базе данных) имеет много разных полей и вложенных объектов,а сами конкретные поля для модели user(для пользователя,типа id,userName и тд) они хранятся в этом объекте user в поле dataValues,если разворачивать просто user(...user),то будет выдавать ошибку,что не может найти нужные поля для UserDto(типа id,userName,email и тд)) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole,так как в postgreSql сделали такие связи таблиц с id)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        return userDto; // в данном случае возвращаем уже обновленный объект пользователя (userDto, только с определенными полями,не всеми,которые есть в базе данных)


    }
    
}

export default new UserService(); // экспортируем уже объект на основе нашего класса UserService,чтобы можно было вызывать эти функции в этом классе через точку(типа userService.registration()),просто импортировав файл userService,если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса