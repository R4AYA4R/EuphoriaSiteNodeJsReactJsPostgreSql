
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл
import ApiError from "../exceptions/ApiError.js";

import bcrypt from 'bcrypt'; // импортируем bcrypt для хеширования пароля(в данном случае импортируем вручную,иначе автоматически не импортируется)
import UserDto from "../dtos/userDto.js";
import tokenService from "./tokenService.js";

// создаем класс UserService,где будем описывать функции для эндпоинтов для сервиса пользователей(их добавление,регистрацию и тд)
class UserService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    // функция регистрации,принимает в параметрах email,userName, и password(которые мы будем получать в теле запроса)
    async registration(email, password, userName) {

        const candidate = await models.User.findOne({ where: { email } }); // ищем один объект в таблице User в базе данных с помощью функции findOne(),передаем условие,что нужно найти объект с полем email как параметр запроса email, и помещаем результат функции findOne(то есть найденный объект с таким же значением в поле email,если он был найден) в переменную candidate

        // если candidate true(то есть переменная candidate есть и в ней есть какое-то не пустое(не null) значение),то есть такой пользователь с таким email уже есть в базе данных
        if (candidate) {

            throw ApiError.BadRequest(`User with email ${email} already exists`);  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        const hashPassword = await bcrypt.hash(password, 3); // хешируем пароль с помощью функции hash() у bcrypt,первым параметром передаем пароль,а вторым - соль,степень хеширования(чем больше - тем лучше захешируется,но не нужно слишком большое число,иначе будет долго хешироваться пароль)

        const userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением USER и помещаем его в переменную userRole

        const user = await models.User.create({ email, password: hashPassword, userName, roleId: userRole.id }); // создаем объект с полями email и password в базу данных и помещаем этот объект в переменную user,в поле password помещаем значение из переменной hashPassword,то есть уже захешированный пароль,и указываем в объекте еще поле userName,в поле roleId передаем значение значение роли,которое мы получили из базы данных выше(то есть передаем в поле roleId id объекта из таблицы Role,у которого поле role равно "USER"(мы поместили этот найденный объект в переменную userRole),то есть таким образом указываем пользователю роль "USER")

        console.log(user);

        const userDto = new UserDto({ ...user.dataValues, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user.dataValues(который мы создали в базе данных,в коде выше,разворачиваем именно так из dataValues,так как сам объект user(созданный в базе данных) имеет много разных полей и вложенных объектов,а сами конкретные поля для модели user(для пользователя,типа id,userName и тд) они хранятся в этом объекте user в поле dataValues,если разворачивать просто user(...user),то будет выдавать ошибку,что не может найти нужные поля для UserDto(типа id,userName,email и тд)) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole,так как в postgreSql сделали такие связи таблиц с id)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        console.log(userDto);

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken);  // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }


    }

    async login(email, password) {

        const user = await models.User.findOne({ where: { email } }); // ищем в базе данных объект с полем email и значением как параметр email этой функции login,то есть проверяем,зарегестрирован ли пользователь вообще,и помещаем найденный(если он найден) объект в переменную user

        // если user false(или null, или другое типа пустое или false значение(undefined,0,"",NaN)),то есть такой пользователь не найден
        if (!user) {

            throw ApiError.BadRequest('User with email not found');  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        console.log(user);

        const isPassEquals = await bcrypt.compare(password, user.password); // сравниваем пароль,который отправил пользователь с захешированным паролем в базе данных,используем функцию compare() у bcrypt,передаем туда первым параметром пароль,который пользователь отправил(параметр этой функции login),а вторым параметром передаем пароль из базы данных(то есть пароль,который есть у объекта user(мы его нашли в переменной user по email),в данном случае не надо указывать user.dataValues.password(это можно указать,но сильного отличия между user.password не будет,это будет и так работать,но если указать user.password,то тогда получим еще кроме самого поля password еще и дополнительные объекты sequelize,связанные с этим объектом user),а сразу можно указать user.password,так как и так находит поле password у user,но в userDto когда нужно развернуть объект user,нужно его указать ...user.dataValues,иначе не разворачивает поля конкретно объекта пользователя user,так как по дефолту при нахождении объекта в базе данных sequelize оборачивает объекты из базы данных в свою обертку,добавляя туда другие объекты,и предыдущее состояние конкретного объекта,а уже конкретные поля объекта хранит в dataValues)

        // если isPassEquals false(или null, или другое типа пустое или false значение(undefined,0,"",NaN)),то есть пароли не одинаковы
        if(!isPassEquals){

            throw ApiError.BadRequest('Wrong password');  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        const userRole = await models.Role.findOne({ where: { role: "USER" } });  // находим объект роли в базе данных со значением USER и помещаем его в переменную userRole

        const userDto = new UserDto({ ...user.dataValues, role: userRole.role }); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект, в который разворачиваем все поля user.dataValues(который мы создали в базе данных,в коде выше,разворачиваем именно так из dataValues,так как сам объект user(созданный в базе данных) имеет много разных полей и вложенных объектов,а сами конкретные поля для модели user(для пользователя,типа id,userName и тд) они хранятся в этом объекте user в поле dataValues,если разворачивать просто user(...user),то будет выдавать ошибку,что не может найти нужные поля для UserDto(типа id,userName,email и тд)) и добавляем поле role со значением userRole.role(то есть само значение поля role у объекта роли userRole,то есть "USER" или "ADMIN",делаем так,чтобы потом возвращать этот объект userDto на клиент и там было удобнее проверять роль у пользователя на значение типа "USER" или "ADMIN",а не на id у объекта userRole,так как в postgreSql сделали такие связи таблиц с id)),в итоге переменная userDto(объект) будет обладать полями id,email,userName,role,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в access и refresh токен) в access и refresh токен

        console.log(userDto);

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken);  // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }


    }


}

export default new UserService(); // экспортируем уже объект на основе нашего класса UserService,чтобы можно было вызывать эти функции в этом классе через точку(типа userService.registration()),просто импортировав файл userService,если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса