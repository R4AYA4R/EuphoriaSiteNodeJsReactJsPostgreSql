import { Sequelize } from "sequelize";
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл


// создаем класс ProductService для сервиса товаров(их удаление,добавление и тд)
class ProductService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    async getProductsArrivals(limit) {

        const products = models.Product.findAll({ order: Sequelize.col('id'), limit }); // помещаем в переменную products все записи(объекты) из базы данных postgreSql у таблицы Product с помощью функции findAll(), указываем сортировку с помощью order,и указываем в массиве по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара),также указываем параметр limit со значением как параметр limit,который мы взяли из url(строки запроса)

        return products; // возвращаем объекты товаров

    }

}

export default new ProductService(); // экспортируем уже объект на основе нашего класса ProductService