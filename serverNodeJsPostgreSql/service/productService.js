import { Op, Sequelize } from "sequelize";
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл


// создаем класс ProductService для сервиса товаров(их удаление,добавление и тд)
class ProductService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    async getProductsArrivals(limit) {

        const products = models.Product.findAll({ order: Sequelize.col('id'), limit }); // помещаем в переменную products все записи(объекты) из базы данных postgreSql у таблицы Product с помощью функции findAll(), указываем сортировку с помощью order,и указываем в массиве по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара),также указываем параметр limit со значением как параметр limit,который мы взяли из url(строки запроса)

        return products; // возвращаем объекты товаров

    }

    // создаем функцию для получения товаров для каталога
    async getProductsCatalog(name) {

        const allProductsPrice = []; // переменная для массива всех цен товаров

        const allProductsForPrice = await models.Product.findAll(); // находим все объекты товаров с помощью findAll() у модели Product и помещаем их в переменную allProductsForPrice

        // проходимся по массиву всех объектов товаров allProductsForPrice и на каждой итерации(то есть для каждого объекта) помещаем в массив allProductsPrice цену каждого товара(product.price), а фильтровать по цене потом будем по полю totalPrice(так как в этом поле будет записана цена товара обычная,или,если есть скидка,то цена со скидкой)
        allProductsForPrice.forEach((product) => {

            allProductsPrice.push(product.price);

        })

        const maxPriceAllProducts = Math.max(...allProductsPrice);  // указываем значение переменной maxPriceAllProducts как максимальное значение из всех цен товаров,Math.max() - выбирает максимальное значение из чисел,в данном случае в Math.max() разворачиваем массив allProductsPrice,то есть вместо него будут подставлены все значения(элементы),которые есть в этом массиве

        // вместо функции findAll() используем findAndCountAll(), используем функцию findAndCountAll,чтобы найти и посчитать сколько объектов пришло из базы данных по данному запросу к базе данных(этот подсчет идет автоматически),то есть допустим по этому запросу с этими фильтрами было найдено 10 объектов,это число 10 будет возвращено на фронтенд в поле count,а в поле rows будут возвращены эти объекты но уже для конкретной страницы,делаем это для пагинации,в таком случае на фронтенд придет объект с полем count в котором будет число объектов всего,которые есть в таблице по этому запросу с этими фильтрами,а в поле rows будут объекты,которые соответствуют параметрам запроса к базе данных для конкретной страницы(то есть которые будут отфильтрованы по лимиту и странице)
        const products = await models.Product.findAndCountAll({
            where:{
                name:{
                    [Op.iLike]:`%${name}%` // указываем у Op метод iLike(он нужен для поиска по полю объектов в базе данных postgreSql,он ищет похожие совпадения по значениям,которые равны в данном случае параметру name(этот параметр мы получили из url от фронтенда,этот параметр с фронтенда мы передаем в этот параметр значение инпута поиска),который мы указали потом через двоеточие),указываем знаки процента перед поисковым параметром name(в данном случае) и после поискового параметра,это значит,что не важно в каком порядке будет написана буква или слово,оно будет просто проверяться,есть ли такая буква у поля объекта или нет(то есть как и нам нужно для поиска),если не указывать эти знаки процента,то поиск будет осуществляться только по полным значениям поля объекта и по конкретному порядку букв и слов у поля объекта( то есть символ процента % означает, что на этом месте может быть что угодно – один символ или сотня, или ни одного ),есть также метод like у Op,но он отличается от iLike тем,что в iLike не важен регистр букв(то есть не важно,заглавные буквы будут или маленькие),а в методе like соблюдается регистр букв,и если будут введены,например,какие-то заглавные буквы,то такие же маленькие буквы у поля объекта не будут находится,также у Op(оператора sequelize) есть другие методы и операторы типа and,or, between(сравнение чисел,типа [Op.between]:[8,10], число между 8 и 10), Op.gt(больше определенного числа,типа [Op.gt]:5, больше 5), Op.in(проверяет,содержится ли значение в конкретном списке значений,типа вместо оператора or, например, [Op.in]:[1,2,3], то есть содержится ли значение поля в хотя бы одном значении элемента этого массива чисел) и тд(можно посмотреть в интернете отдельно)
                },

            },

            // указываем сортировку с помощью order,и указываем в массиве по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара), в данном случае вместо сортировки 'DESC' используем метод col() встроенный в sequelize,он сортирует объекты по полю по возрастанию(от меньшего к большему),в данном случае делаем сортировку по id по возрастанию,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара)
            order:Sequelize.col('id'),

        })

        return { products, maxPriceAllProducts };  // возвращаем из этой функции getProductsCatalog объект с полями массива объектов товаров products(в нем будет поле count(количество объектов товаров,отфильтрованных по фильтрам типа поиску по имени и тд,но без пагинации(то есть не на отдельной странице)),и поле rows(в нем будут объекты товаров,отфильтрованные типа по поиску по имени и тд,но для конкретной страницы пагинации,то есть отфильтрованные еще по параметрам limit и offset)) и переменную maxPriceAllProducts(то есть максимальное значение цены товара,которое мы посчитали и поместили в переменную maxPriceAllProducts),указываем это в объекте,так как передаем уже несколько полей, массив и еще одно поле maxPriceAllProducts

    }

}

export default new ProductService(); // экспортируем уже объект на основе нашего класса ProductService