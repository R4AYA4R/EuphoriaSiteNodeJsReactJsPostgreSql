import { Op, Sequelize } from "sequelize";
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл


// создаем класс ProductService для сервиса товаров(их удаление,добавление и тд)
class ProductService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    async getProductsArrivals(limit) {

        const products = models.Product.findAll({ order: Sequelize.col('id'), limit }); // помещаем в переменную products все записи(объекты) из базы данных postgreSql у таблицы Product с помощью функции findAll(), указываем сортировку с помощью order,и указываем в массиве по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара),также указываем параметр limit со значением как параметр limit,который мы взяли из url(строки запроса)

        return products; // возвращаем объекты товаров

    }

    // создаем функцию для получения товаров для каталога
    async getProductsCatalog(name, typeId, categoryId, maxPrice, minPrice, sizes, sortBy, order, page, limit) {

        let typeIdObj; // указываем переменную для объекта типа,указыаем ей let,чтобы потом изменять ее значение

        let categoryIdObj;

        let priceFilterObj;

        let sizesFilterObj;

        let sortByFilterObj;

        page = page || 1; // указываем значение переменной page как параметр,который взяли из строки запроса,если он не указан,то указываем ему значение 1 

        limit = limit || 2; // указываем значение переменной limit как параметр,который взяли из строки запроса,если он не указан,то делаем значение 2

        let offset = page * limit - limit; // считаем отступ,допустим перешли на вторую страницу и первые 3 товара нужно пропустить(в данном случае это limit),поэтому умножаем page(текущую страницу) на limit и отнимаем лимит,то есть offset считает,сколько нужно пропустить объектов до того,как отправлять объекты(например всего товаров 12, текущая страница 3,лимит 3, соответственно 3 * 3 - 3 будет 6,то есть 6 товаров пропустятся,на следующей странице(4) будет уже пропущено 4 * 3 - 3 равно 9(то есть 9 товаров пропущено будет,и на 10(десятом) уже будут выдаваться товары), offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

        const allProductsPrice = []; // переменная для массива всех цен товаров

        const allProductsForPrice = await models.Product.findAll(); // находим все объекты товаров с помощью findAll() у модели Product и помещаем их в переменную allProductsForPrice

        // проходимся по массиву всех объектов товаров allProductsForPrice и на каждой итерации(то есть для каждого объекта) помещаем в массив allProductsPrice цену каждого товара(product.price), а фильтровать по цене потом будем по полю totalPrice(так как в этом поле будет записана цена товара обычная,или,если есть скидка,то цена со скидкой)
        allProductsForPrice.forEach((product) => {

            allProductsPrice.push(product.price);

        })

        const maxPriceAllProducts = Math.max(...allProductsPrice);  // указываем значение переменной maxPriceAllProducts как максимальное значение из всех цен товаров,Math.max() - выбирает максимальное значение из чисел,в данном случае в Math.max() разворачиваем массив allProductsPrice,то есть вместо него будут подставлены все значения(элементы),которые есть в этом массиве

        // если typeId true(то есть в параметре typeId есть какое-то значение,то указываем значение переменной typeIdObj как объект с полем typeId и значением параметра typeId(который мы взяли из url),в другом случае указываем значение переменной typeIdObj как null,это делаем,чтобы проверить,указан ли typeId,и если нет,то указываем этой переменной значение null,и потом эту переменную(этот объект) typeIdObj разворачиваем в условии для получения объектов товаров из базы данных postgreSql ниже в коде)
        if (typeId) {

            typeIdObj = {
                typeId: typeId
            }

        } else {

            typeIdObj = null;

        }

        if (categoryId) {

            categoryIdObj = {
                categoryId: categoryId
            }

        } else {

            categoryIdObj = null;

        }

        // если minPrice true и maxPrice true(то есть эти параметры true и в них есть не пустое значение,в данном случае при изменении фильтра цены на фронтенде передаем два этих параметра(minPrice и maxPrice) сразу),то изменяем значение priceFilterObj,чтобы фильтровать товары по цене(по полю totalPrice в данном случае)
        if (minPrice && maxPrice) {

            priceFilterObj = {

                totalPrice: {
                    // оператор и,то есть и это,и это,то есть фильтруем поле totalPrice на значение и больше или равно minPrice,и меньше или равно maxPrice
                    [Op.and]: [
                        { [Op.gte]: minPrice }, // оператор gte(greater than or equal),то есть больше или равно,чем minPrice(минимальная цена фильтра в данном случае)

                        { [Op.lte]: maxPrice }, // оператор lte(less than or equal),то есть меньше или равно,чем maxPrice(максимальна цена фильтра в данном случае)
                    ]

                }

            }

        } else {
            // в другом случае,если проверка выше не сработала,то указываем этому объекту priceFilterObj значение как null
            priceFilterObj = null;

        }

        // если sizes true,то есть параметр sizes true и в нем есть не пустое значение,то изменяем объект sizesFilterObj для фильтра товаров по полю sizes
        if (sizes) {

            sizesFilterObj = {
                // Op.contains - содержит ли поле sizes хотя бы один элемент из массива sizes(параметр этой функции getProductsCatalog,то есть query параметр sizes,в данном случае query параметр sizes передаем с фронтенда в url отдельно с каждым значением типа &sizes=S&sizes=M&sizes=XL),например http://localhost:5000/api/&sizes=S&sizes=M&sizes=XL,объекты будут фильтроваться и находится те,у которых есть поле sizes со значением S,M и XL,другие находиться не будут,можно было это сделать по-другому,например,сделать вместо поля sizes у объекта товара сделать поле sizeId,сделать для size отдельную таблицу,связать ее с объектом товара и уже просто вместо этого Op.contains просто указать sizeId(поле у объекта):sizeId(query параметр в url,который тоже потом передавать в url типа &sizeId=1&sizeId=2,где значения sizeId будут равняться определенными значениями записей в таблице size),таким образом тоже будет работать,даже если передавать несколько раз параметр sizeId с разными значениями в url,но в данном случае уже сделали так
                sizes: {
                    [Op.contains]: [sizes]
                }

            }

        } else {

            sizesFilterObj = null;

        }

        // если sortBy true и order true,то есть в sortBy и в order есть какое-то не пустое значение
        if (sortBy && order) {

            sortByFilterObj = {

                order: [
                    [`${sortBy}`, `${order}`]
                ]

            } // вместо sortBy будет подставлено название поля,по которому нужно сортировать(это мы передали с фронтенда),а вместо order будет подставлен метод сортировки,например DESC(сортировка по убыванию),это мы передали с фронтенда

        } else {

            sortByFilterObj = null;

        }

        // ищем все объекты товаров в базе данных,чтобы отправить их на клиент и потом получить число сколько всего товаров в базе данных без пагинации, для отображения их количества потом для каждой категории и тд,также указываем такие же фильтры,как и для переменной products,кроме сортировки типа по рейтингу и тд и кроме пагинации
        const allProductsForCount = await models.Product.findAll({
            where: {

                name: {
                    [Op.iLike]: `%${name}%`
                },

                ...typeIdObj,

                ...categoryIdObj,

                ...sizesFilterObj,

                ...priceFilterObj
            }
        })

        // вместо функции findAll() используем findAndCountAll(), используем функцию findAndCountAll,чтобы найти и посчитать сколько объектов пришло из базы данных по данному запросу к базе данных(этот подсчет идет автоматически),то есть допустим по этому запросу с этими фильтрами было найдено 10 объектов,это число 10 будет возвращено на фронтенд в поле count,а в поле rows будут возвращены эти объекты но уже для конкретной страницы,делаем это для пагинации,в таком случае на фронтенд придет объект с полем count в котором будет число объектов всего,которые есть в таблице по этому запросу с этими фильтрами,а в поле rows будут объекты,которые соответствуют параметрам запроса к базе данных для конкретной страницы(то есть которые будут отфильтрованы по лимиту и странице)
        const products = await models.Product.findAndCountAll({
            where: {
                name: {
                    [Op.iLike]: `%${name}%` // указываем у Op метод iLike(он нужен для поиска по полю объектов в базе данных postgreSql,он ищет похожие совпадения по значениям,которые равны в данном случае параметру name(этот параметр мы получили из url от фронтенда,этот параметр с фронтенда мы передаем в этот параметр значение инпута поиска),который мы указали потом через двоеточие),указываем знаки процента перед поисковым параметром name(в данном случае) и после поискового параметра,это значит,что не важно в каком порядке будет написана буква или слово,оно будет просто проверяться,есть ли такая буква у поля объекта или нет(то есть как и нам нужно для поиска),если не указывать эти знаки процента,то поиск будет осуществляться только по полным значениям поля объекта и по конкретному порядку букв и слов у поля объекта( то есть символ процента % означает, что на этом месте может быть что угодно – один символ или сотня, или ни одного ),есть также метод like у Op,но он отличается от iLike тем,что в iLike не важен регистр букв(то есть не важно,заглавные буквы будут или маленькие),а в методе like соблюдается регистр букв,и если будут введены,например,какие-то заглавные буквы,то такие же маленькие буквы у поля объекта не будут находится,также у Op(оператора sequelize) есть другие методы и операторы типа and,or, between(сравнение чисел,типа [Op.between]:[8,10], число между 8 и 10), Op.gt(больше определенного числа,типа [Op.gt]:5, больше 5), Op.in(проверяет,содержится ли значение в конкретном списке значений,типа вместо оператора or, например, [Op.in]:[1,2,3], то есть содержится ли значение поля в хотя бы одном значении элемента этого массива чисел) и тд(можно посмотреть в интернете отдельно)
                },

                ...typeIdObj, // разворачиваем объект typeIdObj(вместо этого будет подставлено typeIdObj:typeIdObj,если проверка выше на typeIdObj была true,если была false,то тут будет null)

                ...categoryIdObj,

                ...priceFilterObj,

                ...sizesFilterObj

            },

            limit,  // передаем limit(максимальное количество объектов на одной странице,мы его взяли из url от фронтенда) для пагинации

            offset, // offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

            // указываем сортировку с помощью order,и указываем в массиве по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара), в данном случае вместо сортировки 'DESC' используем метод col() встроенный в sequelize,он сортирует объекты по полю по возрастанию(от меньшего к большему),в данном случае делаем сортировку по id по возрастанию,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара)
            order: Sequelize.col('id'),

            ...sortByFilterObj // разворачиваем объект sortByFilterObj,вместо него(если он не равен null) будет подставлено order: и массив с массивом полей и их сортировок(мы их описали в переменной sortByFilterObj выше в коде),если sortByFilterObj будет равен null,то вместо него ничего не будет подставлено

        })

        return { products, maxPriceAllProducts, allProductsForCount };  // возвращаем из этой функции getProductsCatalog объект с полями массива объектов товаров products(в нем будет поле count(количество объектов товаров,отфильтрованных по фильтрам типа поиску по имени и тд,но без пагинации(то есть не на отдельной странице)),и поле rows(в нем будут объекты товаров,отфильтрованные типа по поиску по имени и тд,но для конкретной страницы пагинации,то есть отфильтрованные еще по параметрам limit и offset)) и переменную maxPriceAllProducts(то есть максимальное значение цены товара,которое мы посчитали и поместили в переменную maxPriceAllProducts),указываем это в объекте,так как передаем уже несколько полей, массив и еще одно поле maxPriceAllProducts,также возвращаем поле allProductsForCount со значением массива объектов товаров без пагинации,чтобы отобразить потом количество товаров для каждой категории и тд

    }

    async getProductById(id) {

        // ищем один объект в таблице Product в базе данных с помощью функции findOne() и помещаем его в переменную product,передаем условие,что нужно найти объект с полем id как параметр запроса id(можно было указать where {id:id}, но можно указать один раз id,так как название ключа(поля в объекте) и его значение одинаковые)
        const product = models.Product.findOne({
            where: { id }
        })

        return product; // возвращаем объект товара

    }

}

export default new ProductService(); // экспортируем уже объект на основе нашего класса ProductService