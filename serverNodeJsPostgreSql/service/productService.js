import { Op, Sequelize, where } from "sequelize";
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл
import ApiError from "../exceptions/ApiError.js";

import * as path from 'path'; // импортируем все из модуля path для работы с файлами(в данном случае импортируем вручную и указываем *,то есть берем все из модуля path и указываем название этому всему как path)

import * as uuid from 'uuid'; // импортируем все(*) под названием uuid из модуля uuid,импортируем вручную,так как в данном случае автоматически не импортируется

import fs from 'fs'; // импортируем fs для работы с файлами

// создаем класс ProductService для сервиса товаров(их удаление,добавление и тд)
class ProductService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    async getProductsArrivals(limit) {

        const products = models.Product.findAll({ order: Sequelize.col('id'), limit }); // помещаем в переменную products все записи(объекты) из базы данных postgreSql у таблицы Product с помощью функции findAll(), указываем сортировку с помощью order,и указываем в массиве по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара),также указываем параметр limit со значением как параметр limit,который мы взяли из url(строки запроса)

        return products; // возвращаем объекты товаров

    }

    // создаем функцию для получения товаров для каталога
    async getProductsCatalog(name, typeId, categoryId, maxPrice, minPrice, sizes, sortBy, order, page, limit) {

        let typeIdObj; // указываем переменную для объекта типа,указыаем ей let,чтобы потом изменять ее значение

        let categoryIdObj;

        let priceFilterObj;

        let sizesFilterObj;

        let sortByFilterObj;

        page = page || 1; // указываем значение переменной page как параметр,который взяли из строки запроса,если он не указан,то указываем ему значение 1 

        limit = limit || 2; // указываем значение переменной limit как параметр,который взяли из строки запроса,если он не указан,то делаем значение 2

        let offset = page * limit - limit; // считаем отступ,допустим перешли на вторую страницу и первые 3 товара нужно пропустить(в данном случае это limit),поэтому умножаем page(текущую страницу) на limit и отнимаем лимит,то есть offset считает,сколько нужно пропустить объектов до того,как отправлять объекты(например всего товаров 12, текущая страница 3,лимит 3, соответственно 3 * 3 - 3 будет 6,то есть 6 товаров пропустятся,на следующей странице(4) будет уже пропущено 4 * 3 - 3 равно 9(то есть 9 товаров пропущено будет,и на 10(десятом) уже будут выдаваться товары), offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

        const allProductsPrice = []; // переменная для массива всех цен товаров

        const allProductsForPrice = await models.Product.findAll(); // находим все объекты товаров с помощью findAll() у модели Product и помещаем их в переменную allProductsForPrice

        // проходимся по массиву всех объектов товаров allProductsForPrice и на каждой итерации(то есть для каждого объекта) помещаем в массив allProductsPrice цену каждого товара(product.price), а фильтровать по цене потом будем по полю totalPrice(так как в этом поле будет записана цена товара обычная,или,если есть скидка,то цена со скидкой)
        allProductsForPrice.forEach((product) => {

            allProductsPrice.push(product.price);

        })

        const maxPriceAllProducts = Math.max(...allProductsPrice);  // указываем значение переменной maxPriceAllProducts как максимальное значение из всех цен товаров,Math.max() - выбирает максимальное значение из чисел,в данном случае в Math.max() разворачиваем массив allProductsPrice,то есть вместо него будут подставлены все значения(элементы),которые есть в этом массиве

        // если typeId true(то есть в параметре typeId есть какое-то значение,то указываем значение переменной typeIdObj как объект с полем typeId и значением параметра typeId(который мы взяли из url),в другом случае указываем значение переменной typeIdObj как null,это делаем,чтобы проверить,указан ли typeId,и если нет,то указываем этой переменной значение null,и потом эту переменную(этот объект) typeIdObj разворачиваем в условии для получения объектов товаров из базы данных postgreSql ниже в коде)
        if (typeId) {

            typeIdObj = {
                typeId: typeId
            }

        } else {

            typeIdObj = null;

        }

        if (categoryId) {

            categoryIdObj = {
                categoryId: categoryId
            }

        } else {

            categoryIdObj = null;

        }

        // если minPrice true и maxPrice true(то есть эти параметры true и в них есть не пустое значение,в данном случае при изменении фильтра цены на фронтенде передаем два этих параметра(minPrice и maxPrice) сразу),то изменяем значение priceFilterObj,чтобы фильтровать товары по цене(по полю totalPrice в данном случае)
        if (minPrice && maxPrice) {

            priceFilterObj = {

                totalPrice: {
                    // оператор и,то есть и это,и это,то есть фильтруем поле totalPrice на значение и больше или равно minPrice,и меньше или равно maxPrice
                    [Op.and]: [
                        { [Op.gte]: minPrice }, // оператор gte(greater than or equal),то есть больше или равно,чем minPrice(минимальная цена фильтра в данном случае)

                        { [Op.lte]: maxPrice }, // оператор lte(less than or equal),то есть меньше или равно,чем maxPrice(максимальна цена фильтра в данном случае)
                    ]

                }

            }

        } else {
            // в другом случае,если проверка выше не сработала,то указываем этому объекту priceFilterObj значение как null
            priceFilterObj = null;

        }

        // если sizes true,то есть параметр sizes true и в нем есть не пустое значение,то изменяем объект sizesFilterObj для фильтра товаров по полю sizes
        if (sizes) {

            sizesFilterObj = {
                // Op.contains - содержит ли поле sizes хотя бы один элемент из массива sizes(параметр этой функции getProductsCatalog,то есть query параметр sizes,в данном случае query параметр sizes передаем с фронтенда в url отдельно с каждым значением типа &sizes=S&sizes=M&sizes=XL),например http://localhost:5000/api/&sizes=S&sizes=M&sizes=XL,объекты будут фильтроваться и находится те,у которых есть поле sizes со значением S,M и XL,другие находиться не будут,можно было это сделать по-другому,например,сделать вместо поля sizes у объекта товара сделать поле sizeId,сделать для size отдельную таблицу,связать ее с объектом товара и уже просто вместо этого Op.contains просто указать sizeId(поле у объекта):sizeId(query параметр в url,который тоже потом передавать в url типа &sizeId=1&sizeId=2,где значения sizeId будут равняться определенными значениями записей в таблице size),таким образом тоже будет работать,даже если передавать несколько раз параметр sizeId с разными значениями в url,но в данном случае уже сделали так
                sizes: {
                    [Op.contains]: [sizes]
                }

            }

        } else {

            sizesFilterObj = null;

        }

        // если sortBy true и order true,то есть в sortBy и в order есть какое-то не пустое значение
        if (sortBy && order) {

            sortByFilterObj = {

                order: [
                    [`${sortBy}`, `${order}`],

                    ['id', 'ASC'] // добавляем обязательно еще тут дополнительный массив для сортировки поля id по типу сортировки ASC(от меньшего к большему,она идет по дефолту) или DESC(от большего к меньшему,то есть от последнего добавленного к более старым),но здесь это надо обязательно указать,иначе если идет сортировка по полю с одинаковым значением,а дополнительная сортировка по другому полю не указана(например,по id),то объекты будут показываться в произвольном порядке и дублироваться,и это будет не правильно работать,поэтому здесь добавляем эту сортировку по id,и даже если мы изначально указали order при поиске объектов,то когда мы разворачиваем наш объект sortByFilterObj в параметры поиска функции findAll() ниже в коде,то значение order будет перезаписываться и применяться самое последнее,которое указано самым нижним в коде,то есть даже если мы указали order:Sequelize.col('id') (сортировка типом ASC по полю id),а потом ниже разворачиваем наш объект сортировки sortByFilterObj,то когда этот наш объект sortByFilterObj будет равен не null(то есть когда пользователь на фронтенде выберет сортировку),то значение order будет перезаписано как указано в нашем объекте sortByFilterObj,а уже запись order:Sequelize.col('id') будет не актуальна
                ]

            } // вместо sortBy будет подставлено название поля,по которому нужно сортировать(это мы передали с фронтенда),а вместо order будет подставлен метод сортировки,например DESC(сортировка по убыванию),это мы передали с фронтенда

        } else {

            sortByFilterObj = null;

        }

        // ищем все объекты товаров в базе данных,чтобы отправить их на клиент и потом получить число сколько всего товаров в базе данных без пагинации, для отображения их количества потом для каждой категории и тд,также указываем такие же фильтры,как и для переменной products,кроме сортировки типа по рейтингу и тд и кроме пагинации
        const allProductsForCount = await models.Product.findAll({
            where: {

                name: {
                    [Op.iLike]: `%${name}%`
                },

                ...typeIdObj,

                ...categoryIdObj,

                ...sizesFilterObj,

                ...priceFilterObj
            }
        })

        // вместо функции findAll() используем findAndCountAll(), используем функцию findAndCountAll,чтобы найти и посчитать сколько объектов пришло из базы данных по данному запросу к базе данных(этот подсчет идет автоматически),то есть допустим по этому запросу с этими фильтрами было найдено 10 объектов,это число 10 будет возвращено на фронтенд в поле count,а в поле rows будут возвращены эти объекты но уже для конкретной страницы,делаем это для пагинации,в таком случае на фронтенд придет объект с полем count в котором будет число объектов всего,которые есть в таблице по этому запросу с этими фильтрами,а в поле rows будут объекты,которые соответствуют параметрам запроса к базе данных для конкретной страницы(то есть которые будут отфильтрованы по лимиту и странице)
        const products = await models.Product.findAndCountAll({
            where: {
                name: {
                    [Op.iLike]: `%${name}%` // указываем у Op метод iLike(он нужен для поиска по полю объектов в базе данных postgreSql,он ищет похожие совпадения по значениям,которые равны в данном случае параметру name(этот параметр мы получили из url от фронтенда,этот параметр с фронтенда мы передаем в этот параметр значение инпута поиска),который мы указали потом через двоеточие),указываем знаки процента перед поисковым параметром name(в данном случае) и после поискового параметра,это значит,что не важно в каком порядке будет написана буква или слово,оно будет просто проверяться,есть ли такая буква у поля объекта или нет(то есть как и нам нужно для поиска),если не указывать эти знаки процента,то поиск будет осуществляться только по полным значениям поля объекта и по конкретному порядку букв и слов у поля объекта( то есть символ процента % означает, что на этом месте может быть что угодно – один символ или сотня, или ни одного ),есть также метод like у Op,но он отличается от iLike тем,что в iLike не важен регистр букв(то есть не важно,заглавные буквы будут или маленькие),а в методе like соблюдается регистр букв,и если будут введены,например,какие-то заглавные буквы,то такие же маленькие буквы у поля объекта не будут находится,также у Op(оператора sequelize) есть другие методы и операторы типа and,or, between(сравнение чисел,типа [Op.between]:[8,10], число между 8 и 10), Op.gt(больше определенного числа,типа [Op.gt]:5, больше 5), Op.in(проверяет,содержится ли значение в конкретном списке значений,типа вместо оператора or, например, [Op.in]:[1,2,3], то есть содержится ли значение поля в хотя бы одном значении элемента этого массива чисел) и тд(можно посмотреть в интернете отдельно)
                },

                ...typeIdObj, // разворачиваем объект typeIdObj(вместо этого будет подставлено typeIdObj:typeIdObj,если проверка выше на typeIdObj была true,если была false,то тут будет null)

                ...categoryIdObj,

                ...priceFilterObj,

                ...sizesFilterObj

            },

            limit,  // передаем limit(максимальное количество объектов на одной странице,мы его взяли из url от фронтенда) для пагинации

            offset, // offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

            // указываем сортировку с помощью order,и указываем в массиве по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара), в данном случае вместо сортировки 'DESC' используем метод col() встроенный в sequelize,он сортирует объекты по полю по возрастанию(от меньшего к большему),в данном случае делаем сортировку по id по возрастанию,но в нашем объекте sortByFilterObj все равно нужно дополнительно указать сортировку по id(так как значение order будет перезаписано на самое последнее,самое нижнее в коде),чтобы не менялся порядок объектов при изменении рейтинга у них(если этого не указать,то будет меняться порядок объектов при изменении рейтинга у объекта товара)
            order: Sequelize.col('id'),

            ...sortByFilterObj // разворачиваем объект sortByFilterObj,вместо него(если он не равен null) будет подставлено order: и массив с массивом полей и их сортировок(мы их описали в переменной sortByFilterObj выше в коде),если sortByFilterObj будет равен null,то вместо него ничего не будет подставлено

        })

        return { products, maxPriceAllProducts, allProductsForCount };  // возвращаем из этой функции getProductsCatalog объект с полями массива объектов товаров products(в нем будет поле count(количество объектов товаров,отфильтрованных по фильтрам типа поиску по имени и тд,но без пагинации(то есть не на отдельной странице)),и поле rows(в нем будут объекты товаров,отфильтрованные типа по поиску по имени и тд,но для конкретной страницы пагинации,то есть отфильтрованные еще по параметрам limit и offset)) и переменную maxPriceAllProducts(то есть максимальное значение цены товара,которое мы посчитали и поместили в переменную maxPriceAllProducts),указываем это в объекте,так как передаем уже несколько полей, массив и еще одно поле maxPriceAllProducts,также возвращаем поле allProductsForCount со значением массива объектов товаров без пагинации,чтобы отобразить потом количество товаров для каждой категории и тд

    }

    async getProductById(id) {

        // ищем один объект в таблице Product в базе данных с помощью функции findOne() и помещаем его в переменную product,передаем условие,что нужно найти объект с полем id как параметр запроса id(можно было указать where {id:id}, но можно указать один раз id,так как название ключа(поля в объекте) и его значение одинаковые)
        const product = models.Product.findOne({
            where: { id }
        })

        return product; // возвращаем объект товара

    }

    async updateProductRating(productId, rating) {

        // ищем один объект в таблице Product в базе данных с помощью функции findOne() и помещаем его в переменную product,передаем условие,что нужно найти объект с полем id как параметр запроса productId
        const productFounded = await models.Product.findOne({
            where: { id: productId }
        });

        productFounded.rating = rating; // изменяем поле rating у найденного объекта товара в базе данных(productFounded) на значение поля rating(параметр этой функции updateProductRating)

        await productFounded.save(); // сохраняем обновленный объект товара в базе данных

        return productFounded; // возвращаем измененный объект товара

    }

    async addProductToCart(product) {

        const productCreated = await models.CartProduct.create({ ...product }); // создаем объект товара корзины в базе данных,разворачивая весь объект product(параметр этой функции addProductToCart,то есть это весь объект тела запроса),вместо ...product будут подставлены все поля с их значениями,которые есть в объекте тела запроса

        return productCreated; // возвращаем созданный объект товара в базе данных 

    }

    async getAllProductsCart(userId, page, limit) {

        page = page || 1; // указываем значение переменной page как параметр,который взяли из строки запроса,если он не указан,то делаем значение 1 

        limit = limit || 3;  // указываем значение переменной limit как параметр,который взяли из строки запроса,если он не указан,то делаем значение 3

        let offset = page * limit - limit; // считаем отступ,допустим перешли на вторую страницу и первые 3 товара нужно пропустить(в данном случае это limit),поэтому умножаем page(текущую страницу) на limit и отнимаем лимит(чтобы правильно считались страницы,и показывалась последняя страница с товарами,если не отнять,то на последней странице товаров не будет,так как будет указано пропустить все объекты товаров из базы данных,прежде чем начать отправлять их),то есть offset считает,сколько нужно пропустить объектов до того,как отправлять объекты(например всего товаров 12, текущая страница 3,лимит 3, соответственно 3 * 3 - 3 будет 6,то есть 6 товаров пропустятся,на следующей странице(4) будет уже пропущено 4 * 3 - 3 равно 9(то есть 9 товаров пропущено будет), offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

        const allProductsCartForUser = await models.CartProduct.findAll({ where: { userId } });  // получаем все объекты товаров корзины у которых поле userId равно параметру userId который мы взяли из query параметров url(строки) запроса,то есть получаем все объекты товаров для определенного авторизованного пользователя,это ищем для пагинации и чтобы потом проверять на фронтенде,есть ли такой товар в корзине уже у этого пользователя или нет

        const productsCartForPagination = await models.CartProduct.findAndCountAll({
            where: { userId },

            offset, // offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

            limit, // передаем limit(максимальное количество объектов на одной странице,мы его взяли из url от фронтенда) для пагинации

            order: [
                ['id', 'DESC']
            ] // указываем сортировку с помощью order,и указываем в массиве отдельные массивы для каждого поля,которое нужно сортировать,и уже потом по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы показывались первыми самые последние добавленные товары корзины

        })

        return { allProductsCartForUser, productsCartForPagination }; // возвращаем эти массивы найденных товаров корзины в объект из этой функции getAllProductsCart

    }

    async updateProductCart(productCart) {

        const productCartFounded = await models.CartProduct.findOne({ where: { id: productCart.id } }); // находим объект товара в базе данных по id,который взяли у объекта тела запроса productCart(это будет объект с обновленными данными товара корзины,если пользователь изменил эти данные товара корзины на фронтенде,если пользователь эти данные товара не изменил,то это будет объект товара такой же,как и уже есть в корзине)

        // в данном случае это не надо,так как делаем эту проверку на amount у товара корзины и значение amount в инпуте для изменения количества товара на фронтенде,поэтому не указываем здесь эту проверку,а также,если бы мы не делали эту проверку на фронтенде,то на сервер бы просто уходило много запросов при нажатии на кнопку обновить корзину,поэтому также не делаем эту проверку здесь,а делаем ее на фронтенде
        // если productCartFounded.amount не равно productCart.amount(то есть если количество найденного товара корзины в базе данных(productCartFounded) не равно количеству товара корзины productCart(который мы передали с фронтенда),то тогда изменяем данные товара корзины,в другом случае возвращаем текст типа с ошибкой на клиент(фронтенд))
        // if (productCartFounded.amount !== productCart.amount) {

        productCartFounded.amount = productCart.amount; // изменяем поле amount у productCartFounded(у этого объекта товара корзины,который мы нашли в базе данных) на значение поля amount у productCart(объекта товара,который мы передали с фронтенда)

        productCartFounded.totalPrice = productCart.totalPrice; // изменяем поле totalPrice у productCartFounded(у этого объекта товара корзины,который мы нашли в базе данных) на значение поля totalPrice у productCart(объекта товара,который мы передали с фронтенда)

        await productCartFounded.save();  // сохраняем обновленный объект товара в базе данных

        return productCartFounded; // возвращаем обновленный объект товара корзины из этой функции updateProductCart

        // в данном случае это не надо,так как делаем эту проверку на amount у товара корзины и значение amount в инпуте для изменения количества товара на фронтенде,поэтому не указываем здесь эту проверку,а также,если бы мы не делали эту проверку на фронтенде,то на сервер бы просто уходило много запросов при нажатии на кнопку обновить корзину,поэтому также не делаем эту проверку здесь,а делаем ее на фронтенде 
        // } else {

        //     return `Данные товара с id = ${productCartFounded.id} не были изменены`; // вместо ошибки просто возвращаем строку с сообщением из этой функции updateProductCart,в данном случае просто,чтобы не было куча ошибок в консоли,так как это не критичная ошибка,а просто больше как уведомление

        // }


    }

    async deleteProductCart(productId) {

        const productCartDeleted = await models.CartProduct.destroy({ where: { id: productId } });  // удаляем объект товара корзины у которого id равен параметру productId,который мы взяли из url(строки) запроса

        return productCartDeleted; // возвращаем удаленный объект товара из этой функции deleteProductCart


    }

    async updateProductCartRating(productId, rating) {

        // находим все товары корзины,у которых поле usualProductId равно полю productId(id обычного товара,который взяли из тела запроса),находим все эти товары корзины,так как одинаковые товары могут быть у разных пользователей в корзине(только эти товары могут отличаться количеством,в зависимости от того,сколько выбрал пользователь положить их в корзину),также могут быть в данном случае одинаковые названия товаров и их usualProductId,так как пользователь сможет выбрать один и тот же товара в корзине,но разного размера
        const productsCartFounded = await models.CartProduct.findAll({
            where: { usualProductId: productId }
        });

        // если productsCartFounded true,то есть в корзине есть такие товары,как и в каталоге с таким usualProductId
        if (productsCartFounded) {

            await models.CartProduct.update({ rating: rating }, { where: { usualProductId: productId } }); // обновляем все объекты товаров корзины с помощью update(), у которых поле usualProductId равно полю productId(id обычного товара,который взяли из тела запроса),обновляем у них поле rating на значение поля rating(параметр этой функции updateProductCartRating,то есть это тот новый rating,который взяли из тела запроса)

        }

        return productsCartFounded; // возвращаем из этой функции updateProductCartRating массив найденных товаров корзины(если он пустой,то значение будет null)


    }

    async createNewProductCatalog(productCatalog) {

        const foundedProductCatalog = await models.Product.findOne({ where: { name: productCatalog.name } }); // находим объект товара каталога с полем name как значение поля name у productCatalog(объект тела запроса,то есть объект нового товара,который хочет создать админ)

        // если foundedProductCatalog true,то есть был найден объект товара каталога,с таким же названием,как и у productCatalog(объект тела запроса,то есть объект нового товара,который хочет создать админ)
        if (foundedProductCatalog) {

            throw ApiError.BadRequest('This name already exists'); // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        const mainImagePath = `${path.resolve()}\\checkStatic\\${productCatalog.mainImage}`;  // помещаем путь до файла картинки,которую выбрал админ и она уже находится в папке checkStatic,делаем это,чтобы потом скопировать этот файл картинки по этому пути в папку static,где будут уже все точные сохраненные картинки для товаров(здесь path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsPostgreSql) потом через слеши наша папка checkStatic в которой мы храним все скачанные файлы с фронтенда и еще через слеши указываем название файла картинки)

        let randomStringMainImage = uuid.v4(); // вызываем v4() - возвращает рандомную уникальную строку(другие функции v у uuid,типа v1,v2,v5 и тд генерируют строку на основе времени,mac адреса компьютера(уникальный 12-символьный id,который присваивается каждому сетевому устройству,включая компьютеры,и этот адрес не меняется в отличие от IP адреса) и случайных чисел,а v4 генерируется только на основе рандомных чисел,и поэтому у v4 высокая степень случайности генерации рандомной строки,то есть больше вероятность,что сгенерируется уникальная рандомная строка,чем у других v,а также v4 используется,когда не требуется сохранение порядка или связанность с конкретным временем или устройством),у uuid,и помещаем это значение в переменную randomStringMainImage,делаем эту строку,чтобы изменить название файла в папке static,когда будем его туда перемещать,чтобы у каждого файла было уникальное название,иначе,если название одинаковые у файлов,то они не будут перемещаться в папку static,указываем let этой переменной,чтобы можно было изменять ей значение 

        const mainImagePathStatic = `${path.resolve()}\\static\\(${randomStringMainImage})${productCatalog.mainImage}`; // помещаем путь до картинки товара в нашей папке static(этот путь уже может существовать,если у файла картинки будет уже такое название,но вряд-ли будет такое же название(вероятность сгенерировать рандомно одну и ту же строку очень мала),так как используем генерацию рандомных строк перед основным названием картинки,а также если такого пути нет,то будем по такому пути помещать новую,выбранную админом, картинку для товара) указываем нашу переменную randomStringMainImage перед названием картинки productCatalog.mainImage,чтобы картинка потом правильно сохранилась и имела уникальное название

        const newMainImage = `(${randomStringMainImage})` + productCatalog.mainImage; // создаем переменную для нового названия главной картинки для товара(ее будем сохранять у объекта товара в базе данных),добавляем к основному названию картинки(productCatalog.mainImage) в начало рандомную уникальную строку randomStringMainImage(в скобках ее указываем просто чтобы лучше смотрелось),чтобы каждая картинка в папке static имела рандомное уникальное название,чтобы можно было добавлять картинки с одинаковыми названиями на компьютере,но с разными значениями этих картинок,иначе,даже если картинки разные,но их названия уже есть в папке static,то будет ошибка,что такой файл есть,хотя картинки разные,поэтому делаем так

        // если путь mainImagePathStatic существует(то есть уже есть такой файл главной картинки в папке static(но в данном случае это вряд-ли будет,так как использовали генерацию рандомных строк для названия картинки,то есть вероятность рандомно сгенерировать одну и ту же строку очень мала)),то показываем ошибку,проверяем это с помощью fs.existsSync()
        if (fs.existsSync(mainImagePathStatic)) {

            throw ApiError.BadRequest('This image file already exists'); // throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        // проходимся по массиву descImages у объекта нового товара productCatalog,в descImages будут только названия файлов картинки,и на каждой итерации проверяем,есть ли уже такое название картинки как image в папке static(но в данном случае это вряд-ли будет,так как использовали генерацию рандомных строк для названия картинки,то есть вероятность рандомно сгенерировать одну и ту же строку очень мала),то есть есть ли такая картинка уже в папке static,и если хоть одна из них есть,то возвращаем ошибку,и дальше код выполняться не будет
        productCatalog.descImages.forEach(image => {

            let descImagePath = `${path.resolve()}\\static\\${image}`; // указываем переменной descImagePath let,чтобы можно было изменять ей значение,помещаем в нее возможный путь для картинки описания,то есть если картинка описания с таким же названием как image уже добавилась,то такой путь будет,и проверяем потом ниже в коде существует ли такой путь,и если существует,то показываем ошибку,что такой файл уже есть

            // если путь descImagePath существует(то есть уже есть такой файл картинки описания в папке static),то показываем ошибку,проверяем это с помощью fs.existsSync()
            if (fs.existsSync(descImagePath)) {

                throw ApiError.BadRequest('This image file already exists'); // throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

            }

        })

        const newDescImages = []; // создаем переменную newDescImages для нового массива картинок описания,который будем сохранять у объекта товара в базе данных

        productCatalog.descImages.forEach(image => {

            let randomStringDescImage = uuid.v4(); // вызываем v4() - возвращает рандомную уникальную строку(другие функции v у uuid,типа v1,v2,v5 и тд генерируют строку на основе времени,mac адреса компьютера(уникальный 12-символьный id,который присваивается каждому сетевому устройству,включая компьютеры,и этот адрес не меняется в отличие от IP адреса) и случайных чисел,а v4 генерируется только на основе рандомных чисел,и поэтому у v4 высокая степень случайности генерации рандомной строки,то есть больше вероятность,что сгенерируется уникальная рандомная строка,чем у других v,а также v4 используется,когда не требуется сохранение порядка или связанность с конкретным временем или устройством),у uuid,и помещаем это значение в переменную randomStringDescImage,делаем эту строку,чтобы изменить название файла в папке static,когда будем его туда перемещать,чтобы у каждого файла было уникальное название,иначе,если название одинаковые у файлов,то они не будут перемещаться в папку static,указываем let этой переменной,чтобы можно было изменять ей значение 

            const imageSplit = image.split('.'); // создаем переменную imageSplit и в нее помещаем массив со значением строк из названия картинки,разбитые по символу точки(.),split - разбивает строку по символу и возвращает массив этих разбитых значений строки,то есть отделяем название картинки до точки,и тип картинки после точки типа png и тд

            imageSplit[0] = `(${randomStringDescImage})` + imageSplit[0];  // изменяем элемент по индексу 0 массива imageSplit(то есть дефолтное название картинки до точки,типа до названия расширения картинки,типа png и тд),добавляем к imageSplit[0] (текущее дефолтное название картинки) строку randomStringDescImage (рандомную уникальную строку,указываем ее в скобках просто чтобы лучше смотрелось),чтобы каждая картинка в папке static имела рандомное уникальное название,чтобы можно было добавлять картинки с одинаковыми названиями на компьютере,но с разными значениями этих картинок,иначе,даже если картинки разные,но их названия уже есть в папке static,то будет ошибка,что такой файл есть,хотя картинки разные,поэтому делаем так

            const imageNew = imageSplit.join('.'); // помещаем в переменную imageNew склеенную строку по символу точки(.),join - склеивает массив значений в строку по символу,то есть делаем опять цельное название картинки,но уже с добавленной рандомной уникальной строкой

            console.log(imageNew);

            newDescImages.push(imageNew); // добавляем в массив newDescImages imageNew(новое цельное название картинки,но уже с добавленной рандомной уникальной строкой)

            fs.cpSync(`${path.resolve()}\\checkStatic\\${image}`, `${path.resolve()}\\static\\${imageNew}`); // fs.cpSync - копирует файл или директорию из пути первого параметра в путь второго параметра этой функции(в данном случае первым параметром передали путь до картинки описания в папке checkStatic,а вторым параметром передали путь,в который нужно переместить этот первый путь картинки описания из папки checkStatic,то есть перемещаем файл картинки описания из папки checkStatic,в папку static,но уже с измененным названием,в которое добавили рандомную уникальную строку),делаем это,чтобы в папке static были все точные картинки для товара,а папка checkStatic будет тестовая,чтобы показывать предварительные изображения в форме для админа для создания товара,потом очищаем эту папку checkStatic при обновлении страницы и тд, копируем файл картинки из пути в первом параметре в путь во втором параметре у cpSync(), указываем нашу переменную imageNew,чтобы картинка правильно сохранилась и имела уникальное название

        })

        // и уже после проверок на существующие пути картинок выше в коде сохраняем(копируем) файл главной картинки для товара в папку static
        fs.cpSync(mainImagePath, mainImagePathStatic); // fs.cpSync - копирует файл или директорию из пути первого параметра в путь второго параметра этой функции(в данном случае первым параметром передали mainImagePath(текущий путь главной картинки для товара),а вторым параметром передали mainImagePathStatic,тот путь,в который нужно переместить этот первый путь mainImagePath,то есть перемещаем файл главной картинки из пути в переменной mainImagePath,в путь в переменной mainImagePathStatic),делаем это,чтобы в папке static были все точные картинки для товара,а папка checkStatic будет тестовая,чтобы показывать предварительные изображения в форме для админа для создания товара,потом очищаем эту папку checkStatic при обновлении страницы и тд

        fs.rmSync(path.resolve('checkStatic'), { recursive: true }); // удаляем папку checkStatic,указываем до нее путь с помощью path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsPostgreSql) и добавляет к ней папку,которую мы передаем в параметре,также указываем вторым параметром объект опций,указываем поле recursive:true,то есть папка будет удалена рекурсивно со всем содержимым,очищаем эту папку,чтобы можно было сразу добавлять товары даже с такими же картинками

        // делаем создание товара в базе данных в конце всех проверок на названия фалов и тд,чтобы если будет ошибка,то товар не создался
        const newProductCatalog = await models.Product.create({ ...productCatalog, descImages: newDescImages, mainImage: newMainImage }); // создаем новый объект товара каталога в базе данных,разворачивая весь объект productCatalog(это весь объект тела запроса),вместо ...productCatalog будут подставлены все поля с их значениями,которые есть в объекте тела запроса, указываем отдельно значение полю descImages как newDescImages(новый массив с уникальными названиями картинок) и mainImage как newMainImage(новое уникальное название главной картинки для товара)

        return newProductCatalog; // возвращаем новый созданный объект товара в базе данных из этой функции createNewProductCatalog

    }

    async deleteProductCatalog(productCatalog) {

        const commentsForDeletedProduct = await models.Comment.findAll({ where: { productId: productCatalog.id } }); // ищем все комментарии у которых productId равен id объекта товара,который нужно удалить,который мы взяли из тела запроса(productCatalog.id)

        // если commentsForDeletedProduct true,то есть комментарии для товара,который нужно удалить есть,то их удаляем из базы данных
        if (commentsForDeletedProduct) {

            await models.Comment.destroy({ where: { productId: productCatalog.id } });  // удаляем все комментарии у который productId равен id удаленного товара,который хотим удалить,который взяли из тела запроса

        }

        const deletedProductsCart = await models.CartProduct.findAll({ where: { name: productCatalog.name } }); // ищем все объекты товара в корзине у которых поле name равно полю name объекта товара,который хотим удалить(productCatalog.name)

        // если deletedProductsCart true,то есть товар,который нужно удалить есть в корзине пользователя(или в корзине у нескольких пользователей),то его удаляем из корзины пользователя(или нескольких пользователей) в базе данных
        if (deletedProductsCart) {

            await models.CartProduct.destroy({ where: { name: productCatalog.name } }); // удаляем все объекты товаров в корзине у которых поле name равно полю name объекта товара,который хотим удалить(productCatalog.name),указываем условие именно по полю name,так как нужно удалить все объекты этого товара у всех пользователей,потому что поле name у них одинаковое сохраняется в базе данных в таблице CartProduct,но разные id и userId(это поле нужно,чтобы показать к какому пользователю этот товар принадлежит),поэтому так удаляем их у всех пользователей

        }

        const deletedProductCatalog = await models.Product.destroy({ where: { id: productCatalog.id } }); // удаляем объект товара у которого id равен id товара,который хотим удалить,который взяли из тела запроса(productCatalog.id)

        const mainImagePath = `${path.resolve()}\\static\\${productCatalog.mainImage}`;  // помещаем путь до файла,который хотим удалить в переменную mainImagePath(здесь path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsPostgreSql) потом через слеши наша папка static в которой мы храним все точные скачанные картинки для товара с фронтенда и еще через слеши указываем название файла)

        // если fs.existsSync(mainImagePath) false,то есть файл по такому пути,который находится в переменной mainImagePath не найден,то показываем ошибку и не удаляем такой файл,иначе может быть ошибка,когда хотим удалить файл,что такого файла и так нету
        if (!fs.existsSync(mainImagePath)) {

            throw ApiError.BadRequest('No such file or directory to delete'); // throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        // проходимся по массиву descImages(массив названий картинок описания для товара),в descImages будут только названия файлов картинки,и на каждой итерации проверяем,есть ли такое название картинки как image в папке static,то есть есть ли такая картинка в папке static,и если есть,то удаляем ее,а если нету,то возвращаем ошибку и дальше код выполняться не будет
        productCatalog.descImages.forEach(image => {

            let descImagePath = `${path.resolve()}\\static\\${image}`; // указываем переменной descImagePath let,чтобы можно было изменять ей значение,помещаем в нее возможный путь для картинки описания,то есть если картинка описания с таким же названием как image уже добавилась,то такой путь будет,и проверяем потом ниже в коде существует ли такой путь,и если существует,то удаляем эту картинку,а если не существует,то показываем ошибку,что такого файла нету

            // если путь descImagePath false,то есть такой файл картинки описания в папке static не существует),то показываем ошибку,проверяем это с помощью fs.existsSync()
            if (!fs.existsSync(descImagePath)) {

                throw ApiError.BadRequest('No such file or directory to delete'); // throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

            } else {
                // в другом случае,если путь descImagePath существует(то есть есть этот файл картинки описания),то удаляем эту картинку

                fs.unlinkSync(descImagePath);  // удаляем файл по такому пути,который находится в переменной descImagePath с помощью fs.unlinkSync(),у модуля fs для работы с файлами есть методы обычные(типа unlink) и Sync(типа unlinkSync), методы с Sync блокируют главный поток node js и код ниже этой строки не будет выполнен,пока не будет выполнен метод с Sync

            }

        })

        fs.unlinkSync(mainImagePath); // удаляем файл по такому пути,который находится в переменной mainImagePath с помощью fs.unlinkSync(),у модуля fs для работы с файлами есть методы обычные(типа unlink) и Sync(типа unlinkSync), методы с Sync блокируют главный поток node js и код ниже этой строки не будет выполнен,пока не будет выполнен метод с Sync

        return deletedProductCatalog; // возвращаем из этой функции deletedProductCatalog(если товар каталога был удален успешно,то вернется 1(количество удаленных записей из базы данных, в данном случае удаляли одну эту запись,то есть один объект товара каталога),а если он не был удален,то вернется 0)


    }

    async changeProductPriceCatalog(productCatalog) {

        const foundedProductCatalog = await models.Product.findOne({ where: { id: productCatalog.id } }); // ищем объект товара каталога у которого id равен id товара,который мы взяли из тела запроса(productCatalog.id)

        // если foundedProductCatalog.price !== productCatalog.price,то есть цена найденного объекта товара в базе данных не равна цене объекта товара из тела запроса(productCatalog) или foundedProductCatalog.priceDiscount !== productCatalog.priceDiscount,то цена со скидкой найденного объекта товара не равна цене со скидкой объекта товара из тела запроса(productCatalog),то изменяем значение цены у товара в базе данных и тд,в другом случае показываем ошибку,делаем так,чтобы нельзя было просто изменить значение обычной цены и цены со скидкой у объекта товара в базе данных на такое же,как предыдущее
        if (foundedProductCatalog.price !== productCatalog.price || foundedProductCatalog.priceDiscount !== productCatalog.priceDiscount) {

            foundedProductCatalog.price = productCatalog.price; // изменяем поле price у foundedProductCatalog(у товара каталога) на значение поля price у productCatalog(объект товара,который мы взяли из тела запроса)

            foundedProductCatalog.priceDiscount = productCatalog.priceDiscount; // изменяем поле priceDiscount у foundedProductCatalog(у товара каталога) на значение поля priceDiscount у productCatalog(объект товара,который мы взяли из тела запроса)

            foundedProductCatalog.totalPrice = productCatalog.totalPrice; // изменяем поле totalPrice у foundedProductCatalog(у товара каталога) на значение поля totalPrice у productCatalog(объект товара,который мы взяли из тела запроса)

            await foundedProductCatalog.save(); // сохраняем объект товара каталога в базе данных

            const foundedProductsCart = await models.CartProduct.findAll({ where: { name: productCatalog.name } });  // ищем все объекты товаров у которых name равен полю name у productCatalog(объект товара,который мы взяли из тела запроса),ищем эти объекты товаров по полю name,так как поле name может быть одинаковое у товаров в корзине,но у разных пользователей,поэтому находим все

            // если foundedProductsCart true,то есть объекты товаров в корзине были найдены
            if (foundedProductsCart) {

                // проходимся по массиву найденных товаров корзины(если они были найдены),указываем async для функции внутри forEach,так как делаем там асинхронный запрос к базе данных для сохранения товара в базе данных,и на каждой итерации этого массива изменяем поля price и totalPrice этого товара в корзине
                foundedProductsCart.forEach(async (productCart) => {

                    productCart.price = productCatalog.price;  // изменяем поле price у этого товара корзины(productCart) на значение поля price у productCatalog(объект товара каталога,который мы взяли из тела запроса)

                    // если productCatalog.priceDiscount больше 0,то есть поле priceDiscount у productCatalog(объект тела запроса) больше 0,то есть цена со скидко указана,то изменяем поле totalPrice на значение количества товара,умноженное на цену со скидкой
                    if (productCatalog.priceDiscount > 0) {

                        productCart.totalPrice = productCart.amount * productCatalog.priceDiscount; // изменяем поле totalPrice у этого товара корзины(productCart) на значение поля amount у этого товара корзины(productCart),умноженное на поле priceDiscount у productCatalog(объект товара каталога,который мы взяли из тела запроса),то есть считаем общую цену товара со старым значением количества товара в корзине(amount,у каждого пользователя оно может быть разным),но уже с новым значением цены товара со скидкой(productCatalog.priceDiscount), делаем так,так как в корзине будет считаться общий счет и тд по полю totalPrice,и если не сделать проверку,есть ли цена со скидкой,и просто умножить количество товара на его обычную цену,то оно не будет считать цену со скидкой

                    } else {
                        // в другом случае,если поле priceDiscount меньше или равно 0(то есть оно не указано),то изменяем поле totalPrice на значение количества товара,умноженное на его обычную цену
                        productCart.totalPrice = productCart.amount * productCatalog.price;  // изменяем поле totalPrice у этого товара корзины(productCart) на значение поля amount у этого товара корзины(productCart),умноженное на поле price у productCatalog(объект товара каталога,который мы взяли из тела запроса),то есть считаем общую цену товара со старым значением количества товара в корзине(amount,у каждого пользователя оно может быть разным),но уже с новым значением цены товара(productCatalog.price)

                    }

                    productCart.priceDiscount = productCatalog.priceDiscount;  // изменяем поле priceDiscount у productCart(текущий итерируемый объект товара корзины) на значение поля priceDiscount у productCatalog(объект товара,который мы взяли из тела запроса)

                    await productCart.save(); // сохраняем этот обновленный объект товара корзины в базе данных

                })

            }

            return { foundedProductCatalog, foundedProductsCart }; // возвращаем из этой функции changeProductPriceCatalog объект с полями измененного объекта товара каталога и обновленного массива товаров корзины,если они были найдены,возвращаем именно объект,так как уже указываем несколько полей в этом объекте,если не вернуть объект для нескольких полей,то выдает ошибку

        } else {

            throw ApiError.BadRequest('New price product or new discount price must be different from previous value'); // throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

    }

    async deleteDescImage(productId, imageName) {

        const imagePath = `${path.resolve()}\\static\\${imageName}`; // помещаем путь до файла,который хотим удалить в переменную imagePath(здесь path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsPostgreSql) потом через слеши наша папка static в которой мы храним все точные скачанные картинки для товара с фронтенда и еще через слеши указываем название файла)

        // если fs.existsSync(imagePath) false,то есть файл по такому пути,который находится в переменной imagePath не найден,то показываем ошибку и не удаляем такой файл,иначе может быть ошибка,когда хотим удалить файл,что такого файла и так нету
        if (!fs.existsSync(imagePath)) {

            throw ApiError.BadRequest('No such file or directory to delete'); // throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        fs.unlinkSync(imagePath); // удаляем файл по такому пути,который находится в переменной imagePath с помощью fs.unlinkSync(),у модуля fs для работы с файлами есть методы обычные(типа unlink) и Sync(типа unlinkSync), методы с Sync блокируют главный поток node js и код ниже этой строки не будет выполнен,пока не будет выполнен метод с Sync

        const foundedProductCatalog = await models.Product.findByPk(productId); // ищем объект товара в базе данных по id productId(id товара,который передали с фронтенда,чтобы у этого товара удалить картинку описания),лучше использовать метод findByPk(),вместо findOne(),когда хотим получить объект по первичному ключу(то есть в данном случае по id),так как findByPk будет более эффективен и быстр,а также быстрее указывать его,так как не надо внутри указывать условие,что ищем по id,если объект не будет найден,то будет возвращен null

        console.log(foundedProductCatalog);

        foundedProductCatalog.descImages = foundedProductCatalog.descImages.filter(imgName => imgName !== imageName); // фильтруем массив descImages и оставляем в массиве только те названия картинок,которые не равны imageName(название картинки,которые мы передали с фронтенда,которую нужно удалить),таким образом удаляем из этого массива картинку imageName,которую и хотели удалить

        await foundedProductCatalog.save(); // сохраняем обновленный объект товара в базе данных

        return { message: 'Successfully deleted', foundedProductCatalog }; // возвращаем из этой функции deleteDescImage объект с полями измененного объекта товара каталога и типа строку с сообщением,если они были найдены,возвращаем именно объект,так как уже указываем несколько полей в этом объекте,если не вернуть объект для нескольких полей,то выдает ошибку


    }

}

export default new ProductService(); // экспортируем уже объект на основе нашего класса ProductService,чтобы можно было вызывать эти функции в этом классе через точку(типа productService.generateTokens()),просто импортировав файл productService,если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса