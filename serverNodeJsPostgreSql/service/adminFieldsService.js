

import { Op, Sequelize } from "sequelize";
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл
import ApiError from "../exceptions/ApiError.js";


// создаем класс AdminFieldsService для сервиса комментариев(их удаление,добавление и тд)
class AdminFieldsService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    async changeEmail(newEmail, errors) {

        const foundedAdminFields = await models.AdminFields.findOne({}); // ищем объект у таблицы(сущности) AdminFields в базе данных и помещаем его в переменную foundedAdminFields,передаем в findOne() пустой объект,чтобы найти первую попавшуюся запись у таблицы(сущности) AdminFields(так как она там и так одна для всех полей,то ее так и находим),находим этот объект(он будет один со всеми нужными полями,так как мы его так создали в базе данных),в нем будут поля со значением текстов и разных полей на сайте,ищем и будем отображать потом на сайте,чтобы потом мог админ изменять их в базе данных

        // если foundedAdminFields.email(почта у найденного объекта админ полей,то есть почта,которая уже есть в базе данных у этого объекта) равно newEmail(новая почта,которую взяли из тела запроса),то показываем ошибку
        if (foundedAdminFields.email === newEmail) {

            throw ApiError.BadRequest('New email must be different from previous email'); // throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением 

        }

        // если errors.isEmpty() false,то есть массив ошибок не пустой,этот параметр errors мы передали в эту функцию changeEmail из adminFieldsController(этот параметр errors является результатом валидации поля email с помощью валидатора body(то есть если есть ошибки при валидации поля email,то показываем ошибку),это мы прописывали у эндпоинта /changeEmail)
        if (!errors.isEmpty()) {

            throw ApiError.BadRequest('Enter email correctly', errors.array()); // бросаем ошибку и в нашу функцию BadRequest() передаем сообщение для ошибки и массив ошибок,полученных при валидации с помощью errors.array(), throw тоже завершает функцию на этой строчке кода,как и return,а также на строчке throw сразу попадает в блок catch у родительской функции(если этот блок catch был описан,если не был,то будет ошибка,что типа не обработана ошибка с помощью try catch) вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,этот объект ошибки из функции BadRequest попадет в функцию next() (наш error middleware) у функции для эндпоинта,так как в ней мы отлавливали ошибки с помощью try catch и здесь указали throw,и эта ошибка там будет обработана,то есть показываем ошибку с сообщением

        }

        foundedAdminFields.email = newEmail; // изменяем поле email у этого найденного объекта для админ полей(foundedAdminFields) на значение поля newEmail(новую почту,которую взяли из тела запроса)

        await foundedAdminFields.save(); // сохраняем обновленный объект полей для админа в базе данных

        return foundedAdminFields; // возвращаем обновленный объект foundedAdminFields из этой функции changeEmail

    }

    async getAdminFields() {

        const foundedAdminFields = await models.AdminFields.findOne({}); // ищем объект у таблицы(сущности) AdminFields в базе данных и помещаем его в переменную foundedAdminFields,передаем в findOne() пустой объект,чтобы найти первую попавшуюся запись у таблицы(сущности) AdminFields(так как она там и так одна для всех полей,то ее так и находим),находим этот объект(он будет один со всеми нужными полями,так как мы его так создали в базе данных),в нем будут поля со значением текстов и разных полей на сайте,ищем и будем отображать потом на сайте,чтобы потом мог админ изменять их в базе данных

        return foundedAdminFields; // возвращаем обновленный объект foundedAdminFields из этой функции changeEmail

    }

}

export default new AdminFieldsService(); // экспортируем уже объект на основе нашего класса AdminFieldsService,чтобы можно было вызывать эти функции в этом классе через точку(типа adminFieldsService.generateTokens()),просто импортировав файл AdminFieldsService,если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса