
import { Op, Sequelize } from "sequelize";
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл


// создаем класс CommentService для сервиса комментариев(их удаление,добавление и тд)
class CommentService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    async createComment(comment) {

        const commentData = await models.Comment.create({ ...comment }); // создаем объект комментария в базе данных,разворачивая весь объект comment(это весь объект тела запроса),вместо ...comment будут подставлены все поля с их значениями,которые есть в объекте тела запроса

        return commentData; // возвращаем созданный объект комментария

    }

    async getCommentsForProduct(productId) {

        const commentsData = await models.Comment.findAll({ where: {productId} });  // получаем все объекты комментариев,у которых productId равен параметру productId(параметр этой функции getCommentsForProduct),который мы взяли из url(строки) запроса

        return commentsData; // возвращаем массив найденных комментариев

    }


}

export default new CommentService(); // экспортируем уже объект на основе нашего класса CommentService,чтобы можно было вызывать эти функции в этом классе через точку(типа сommentService.generateTokens()),просто импортировав файл CommentService,если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса