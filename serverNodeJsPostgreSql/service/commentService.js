
import { Op, Sequelize } from "sequelize";
import models from "../models/models.js"; // указываем тут расширение файла как .js вручную,иначе не находит файл


// создаем класс CommentService для сервиса комментариев(их удаление,добавление и тд)
class CommentService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка и вернуть ответ от сервера с ошибкой на клиент,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи и возвращать на клиент ошибку,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функцию типа errorMiddleware и там обрабатывать ошибку))

    async createComment(comment) {

        const commentData = await models.Comment.create({ ...comment }); // создаем объект комментария в базе данных,разворачивая весь объект comment(это весь объект тела запроса),вместо ...comment будут подставлены все поля с их значениями,которые есть в объекте тела запроса

        return commentData; // возвращаем созданный объект комментария

    }

    async getCommentsForProduct(productId, page, limit) {

        page = page || 1;  // указываем значение переменной page как параметр,который взяли из строки запроса(из параметров этой функции в данном случае),если он не указан,то делаем значение 1 

        limit = limit || 2;  // указываем значение переменной limit как параметр,который взяли из строки запроса(из параметров этой функции в данном случае),если он не указан,то делаем значение 2

        let offset = page * limit - limit; // считаем отступ,допустим перешли на вторую страницу и первые 3 товара нужно пропустить(в данном случае это limit),поэтому умножаем page(текущую страницу) на limit и отнимаем лимит(чтобы правильно считались страницы,и показывалась последняя страница с товарами,если не отнять,то на последней странице товаров не будет,так как будет указано пропустить все объекты товаров из базы данных,прежде чем начать отправлять их),то есть offset считает,сколько нужно пропустить объектов до того,как отправлять объекты(например всего товаров 12, текущая страница 3,лимит 3, соответственно 3 * 3 - 3 будет 6,то есть 6 товаров пропустятся,на следующей странице(4) будет уже пропущено 4 * 3 - 3 равно 9(то есть 9 товаров пропущено будет), offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

        let allCommentsForProduct = []; // указываем переменную для комментариев для конкретного товара и указываем ей по дефолту пустой массив,указываем ей let,чтобы изменять ей значение и чтобы можно было ее указать в блоке проверки,но все равно,если эта проверка не пройдет,то вернуть на клиент хотя бы пустой массив

        let commentsForPagination = [];  // указываем переменную для комментариев для конкретного товара для пагинации и указываем ей по дефолту пустой массив,указываем ей let,чтобы изменять ей значение и чтобы можно было ее указать в блоке проверки,но все равно,если эта проверка не пройдет,то вернуть на клиент хотя бы пустой массив

        const allComments = await models.Comment.findAll({}); // находим все объекты комментариев с помощью findAll() у модели Comment,передаем туда пустой объект(это не обязательно,просто это значит,что никаких опций и параметров туда не передаем) и помещаем их в переменную allComments,не указываем,что ищем по id товара(productId),так как потом будем фильтровать его сами на фронтенде по id товара,чтобы отобразить комментарии для каждого товара,чтобы не было дополнительно много запросов на сервер

        // если productId true,то есть параметр productId есть,указываем эту проверку,чтобы не было ошибки,что productId undefined,так как будем использовать этот эндпоинт для секции sectionNewArrivals на фронтенде и не будем там передавать параметр productId,можно было просто сделать для этого отдельный эндпоинт,чтобы получить только все комментарии,но в целом и это подходит и уже сделали так
        if (productId) {

            allCommentsForProduct = await models.Comment.findAll({ where: { productId } }); // находим все объекты комментариев с помощью findAll() у модели Comment,у которых productId равен параметру productId,который мы взяли из url(строки) запроса,можно было указать и productId:productId,но так как названия параметра(который мы взяли из параметров запроса) и поля одинаковые,то можно указать просто productId и помещаем их в переменную allCommentsForProduct,это ищем для того,чтобы посчитать на клиенте общий рейтинг комментариев для товара

            commentsForPagination = await models.Comment.findAndCountAll({

                where: { productId },

                limit, // передаем limit(максимальное количество объектов на одной странице,мы его взяли из url от фронтенда) для пагинации

                offset, // offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

                // указываем сортировку с помощью order,и указываем в массиве отдельные массивы для каждого поля,которое нужно сортировать,и уже потом по какому полю какую сортировку делать,DESC - сортировка по убыванию(от большего к меньшему),ASC - сортировка от меньшего к большему,она идет по умолчанию,в данном случае сортируем поле id сортировкой DESC,то есть от большего к меньшему,в данном случае это делаем,чтобы показывались первыми самые последние добавленные комментарии
                order: [
                    ['id', 'DESC']
                ]

            });  // получаем все объекты комментариев,у которых productId равен параметру productId(параметр этой функции getCommentsForProduct),который мы взяли из url(строки) запроса,делаем это уже для пагинации комментариев,то есть будем это использовать,чтобы отобразить комментарии на каждой отдельной странице пагинации

        }



        return { allComments, allCommentsForProduct, commentsForPagination }; // возвращаем эти массивы найденных комментариев в объект из этой функции getCommentsForProduct

    }

    async addReplyForComment(comment) {

        const foundedComment = await models.Comment.findByPk(comment.id); // находим объект комментария в базе данных по id,который равен id у comment(объект тела запроса)

        foundedComment.adminReply = comment.adminReply; // изменяем поле adminReply у найденного объекта комментария на поле adminReply у comment(объект тела запроса,который передали с фронтенда)

        await foundedComment.save(); // сохраняем этот обновленный объект комментария в базе данных

        return foundedComment; // возвращаем измененный объект комментария из этой функции addReplyForComment

    }

    async deleteReplyFromAdmin(commentId) {

        const foundedComment = await models.Comment.findByPk(commentId);  // находим объект комментария в базе данных по id,который равен commentId (id у объекта комментария)

        foundedComment.adminReply = null; // изменяем поле adminReply у найденного объекта комментария на null,таким образом удаляем ответ от админа

        await foundedComment.save(); // сохраняем этот обновленный объект комментария в базе данных

        return foundedComment; // возвращаем измененный объект комментария из этой функции deleteReplyFromAdmin

    }

    async deleteComment(commentId) {

        const deletedComment = await models.Comment.destroy({ where: { id: commentId } }); // удаляем объект комментария,у которого id равен commentId (id у объекта комментария,который взяли из параметров запроса)

        return deletedComment; // возвращаем из этой функции deletedComment(если объект комментария был удален успешно,то вернется 1(количество удаленных записей из базы данных, в данном случае удаляли одну эту запись,то есть один объект комментария),а если он не был удален,то вернется 0)

    }

}

export default new CommentService(); // экспортируем уже объект на основе нашего класса CommentService,чтобы можно было вызывать эти функции в этом классе через точку(типа сommentService.generateTokens()),просто импортировав файл CommentService,если так не делать,то если у функций класса нету параметра static,то нельзя будет их вызвать,не создав перед этим объект на основе этого класса