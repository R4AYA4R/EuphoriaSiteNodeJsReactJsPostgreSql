// лучше создать, подключить git репозиторий в проект,сделать первый commit и push данных в git до того,как создали папку с фронтендом на react js,иначе могут быть ошибки(могут и не быть) сохранений git папки всего проекта и git папки самого фронтенда на react js,также здесь будем использовать gitlab для ci cd пайплайна,поэтому нужно также подключить gitlab,чтобы туда также пушились изменения в коде,поэтому кроме добавления origin для гитхаба,нужно добавить еще origin для гитлаба, командой git remote set-url --add origin(origin здесь это имя для репозитория(вместо его url) и лучше создать 2 разных имени для гитхаб репозитория и гитлаб,чтобы потом не путаться,но в данном случае оставили название origin,чтобы комнадой git push -u origin и название ветки,пушилось сразу в два репозитория с этим именем origin,командой git remote show можно увидеть имена для подключенных удаленных репозиториев(типа на гитхабе или гитлабе)) и ссылка на гитлаб репозиторий,добавляет отслеживание репозитория гитлаба и возможность пушить изменения еще и в гитлаб репозиторий,команда git push -u origin master пушит изменения в репозиторий для ветки master,слово origin здесь - это просто имя репозитория(вместо его url),а флаг -u устанавливает отслеживание ветки,которую мы указали(master в данном случае),чтобы потом можно было использовать команду git push и не указывать уже какую ветку пушить,так как до этого ее так указали,но в первый раз при пуше в репозиторий гитлаба нужно будет в всплывающем окне войти в свой аккаунт гитлаба,чтобы запушились изменения,или можно вместо этого сразу подключить репозиторий гитлаба командой git remote add origin и ссылка на гитлаб репозиторий,а потом уже командой git remote set-url --add origin и ссылка на гитхаб репозиторий добавить url репозитория гитхаба,но в этом url тогда лучше будет указать токен доступа,который можно создать в настройках профиля developer settings,и там создать access token(classic),выбрать параметры доступа и сгенерировать этот ключ,потом его в этом url репозитория указать и таким образом подключиться к репозитории гитхаба,но лучше сразу гитхаб подключить,а потом гитлаб,также чтобы вручную в гитлабе не мержить(merge,сливать вместе) новую ветку master(так как по дефолту главная ветка в гитлаб репозитории называется main),то нужно в настройках в repository указать default branch(дефолтную главную ветку) на master

// прописали npm init в проект,чтобы инициализировать npm менеджер пакетов,чтобы устанавливать зависимости и пакеты(после npm init на все вопросы можно нажать enter и они будут тогда по дефолту указаны),устанавливаем express,cors(для отправки запросов через браузер),cookie-parser, устанавливаем с помощью npm i,устанавливаем nodemon(npm i nodemon --save-dev(чтобы устанавилось только для режима разработки)),чтобы перезагружался сервер автоматически при изменении файлов,указываем в package json в поле scripts поле dev и значение nodemon index.js(чтобы запускался index.js с помощью nodemon,чтобы перезагружался сервер автоматически при изменении файлов),используем команду npm run dev,чтобы запустить файл index.js,добавляем поле type со значение module в package.json,чтобы работали импорты типа import from,устанавливаем dotenv(npm i dotenv),чтобы использовать переменные окружения,создаем файл .env в корне папки server,чтобы указывать там переменные окружения(переменные среды),устанавливаем npm i mongodb mongoose,для работы с базой данных mongodb,на сайте mongodb создаем новый проект для базы данных,и потом берем оттуда ссылку для подключения к базе данных,устанавливаем еще jsonwebtoken(для генерации jwt токена),bcrypt(для хеширования пароля),uuid(для генерации рандомных строк) (npm i jsonwebtoken bcrypt uuid),все модули для backend(бэкэнда,в данном случае в папке server) нужно устанавливать в папку для бэкэнда(в данном случае это папка server),для этого нужно каждый раз из корневой папки переходить в папку server(cd server) и уже там прописывать npm i,устанавливаем еще пакет nodemailer(npm i nodemailer) для работы с отправкой сообщений на почту,устанавливаем библиотеку express-validator(npm i express-validator) для валидации паролей,почт и тд(для их проверки на правилно введенную информацию),для работы с файлами в express, нужно установить модуль npm i express-fileupload,лучше создать, подключить git репозиторий в проект,сделать первый commit и push данных в git до того,как создали папку с фронтендом на react js,иначе могут быть ошибки(могут и не быть) сохранений git папки всего проекта и git папки самого фронтенда на react js

// в данном случае используем postgreSql вместо mongodb,поэтому ниже комментарии для подключение и работы с postgreSql,но сначала устанавливаем все нужные зависимости(библиотеки),которые в комментарии выше,кроме библиотек для mongodb
// указываем команду в терминале npm init -y(-y нужен,чтобы установить настройки по умолчанию автоматически,если бы не писали -y,то надо было бы нажимать enter на каждый вопрос,который будет написан после команды npm init,чтобы установить настройки по умолчанию),потом устанавливаем npm install express(для node js express), pg(для postgreSql), pg-hstore(для postgreSql), sequelize(чтобы взаимодействовать с базой данных postgreSql более просто), cors(чтобы можно было отправлять запросы на сервер из браузера), dotenv(чтобы задавать переменные окружения), устанавливаем npm i nodemon --save-dev(чтобы при сохранении файла перезагружался сервер автоматически, --save-dev значит,что устанавливаем только для режима разработки),в файле package.json в поле scripts указываем поле с названием dev(это будет название команды) и со значением nodemon index.js(чтобы по команде npm run dev запускался сервер и потом чтобы при сохранении файла перезагружался сервер автоматически),указываем в package.json поле type со значением module,чтобы работали импорты,создаем файл .env для описания переменных окружения(просто переменных,которые потом будет использовать в разных файлах), в программе pgAdmin(она устанавливается вместе с установкой postgreSql на компьютер) вводим пароль для подключения к postgres(этот пароль мы задавали при установке postgreSql на компьютер) и создаем новую базу данных,нажимая правой кнопкой мыши по вкладке databases и выбираем create,вводим там название базы данных и сохраняем,потом можно построить диаграмму базы данных(описание таблиц и полей в таблицах в нарисованном виде),это можно сделать например,на сайте app.diagrams.net,можно написать просто draw io,у каждой сущности(таблицы в базе данных) должен быть уникальный идентификатор(id),связь у таблиц 1 к 1(один к одному) значит,что один объект таблицы может принадлежать(иметь ссылку на объект другой таблицы) только одному другому объекту другой таблицы, свзять таблиц 1 ко многим значит,что один объект таблицы может принадлежать(иметь ссылку на объект другой таблицы) нескольким объектам других таблиц(типа тип товара может быть у многих объектов товаров), в pgAdmin во вкладке нужной базы данных(в данном случае postgreSqlSequelizeNodeJs),во вкладке schemas во вкладке public и во вкладке tables,можем найти наши созданные таблицы,чтобы посмотреть все записи в таблице,нужно нажать на таблицу правой кнопкой мыши и выбрать View/Edit Data(Просмотр или редактирование данных) и там выбрать All Rows(Все строки),
// чтобы переобновить даннные в этой таблице,можно еще раз нажать на просмотр и редактирование данных,тогда оно еще раз переобновится,устанавливаем (npm i) express-fileupload для загрузки файлов на сервер, устанавливаем (npm i) uuid для генерации рандомных строк(для рандомной генерации названия файла в данном случае),создаем папку static,в ней будем хранить файлы,которые будем загружать с фронтенда,а потом на фронтенд отдавать, чтобы удалить объект из таблицы в базе данных postgreSql с помощью sequelize,то надо использовать функцию destroy() у модели(таблицы),которую создали, типа Device.destroy({where:{id:1}}),то есть удаляем объект из таблицы Device у которого поле id равно 1(указываем условие с помощью where), чтобы обновить данные в таблице у объекта,нужно использовать функцию update(),типа Device.update({title: 'text'}, {where:{id:2}}), то есть обновляем поле title строку text(в данном случае) у объекта,у торого id равно 2(указываем условие с помощью where)

//authMiddleware нужен,чтобы защитить пользователя от мошенников,так как,когда истекает access токен,идет запрос на refresh токен,и после этого обновляется и access токен,и refresh токен,соответственно мошенник уже не может получить доступ к этому эндпоинту(маршруту по url),так как его refresh и access токен будут уже не действительны,а функция checkAuth нужна для проверки только refresh токена(то есть,если пользователь вообще не пользовался сервисом какое-то время(которое указали у жизни refresh токена),нужно именно не переобновлять страницы и тд,чтобы не шел запрос на /refresh(иначе refresh токен будет переобновляться с каждым запросом,нужно,чтобы refresh токен истек до запроса на /refresh),то его refresh токен истечет и его выкинет с аккаунта после обновления страницы,но если пользователь будет использовать в данном случае,например,функцию authMiddleware,то его access токен и refresh токен будут заново перезаписаны и таймер на время жизни refresh токена будет обновлен и заново запущен,поэтому его не будет выкидывать из аккаунта) 

import express from 'express'; // импортируем express(express типа для node js express,в данном случае импортируем это вручную,потому что автоматически не импортируется)

import dotenv from 'dotenv';  // импортируем dotenv(в данном случае импортируем это вручную,потому что автоматически не импортируется)
import db from './db.js';

dotenv.config(); // используем config() у dotenv,чтобы работал dotenv и можно было использовать переменные окружения

const PORT = process.env.PORT || 5000; // указываем переменную PORT и даем ей значение как у переменной PORT из файла .env,если такой переменной нет,то указываем значение 5000

const app = express(); // создаем экземпляр нашего приложения с помощью express()

// делаем эту функцию start асинхронной,так как все операции с базой данных являются асинхронными
const start = async () => {

    // оборачиваем в try catch,чтобы отлавливать ошибки
    try{

        await db.authenticate(); // с помощью функции authenticate() у db(объекта,который мы импортировали на основе класса sequelize для работы с базой данных postgreSql) подключаемся к базе данных postgreSql

        await db.sync(); // используем функцию sync(),чтобы эта функция сверяла состояние базы данных со схемой данных которую мы опишем

        app.listen(PORT,() => console.log(`Server started on PORT = ${PORT}`)); // запускаем сервер,говоря ему прослушивать порт 5000(указываем первым параметром у listen() нашу переменную PORT) с помощью listen(),и вторым параметром указываем функцию,которая выполнится при успешном запуске сервера

    }catch(e){

        console.log(e);

    }

}
 
start(); // вызываем нашу функцию start(),чтобы запустить сервер