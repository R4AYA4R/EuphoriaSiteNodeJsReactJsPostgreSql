# здесь описаны все стадии для джобов(типа билд(сборка),тест,деплой и тд),они будут запускаться по порядку сверху вниз,следющий не запустится,пока предыдущий не закончил
stages:
  - build
  - test
  - deploy

# здесь указываем название джобы
build-job:
  # здесь указываем название стадии(которую мы указывали чуть выше в поле stages) для этой джобы  
  stage: build
  # здесь указываем команды,которые будут выполнены в консоли для этой джобы,в данном случае указываем команду для сборки нашего докер образа,даем ему название как euphoriaServerNodeJs и указываем . ,то есть указываем,что Dockerfile находится в текущей директории,в которой находится файл .gitlab-ci.yml,но в данном случае,так как создали отдельную папку для сервера(serverNodeJs) и перенесли Dockerfile для сервера туда,то указываем уже путь до этого Dockerfile как ./serverNodeJsPostgreSql,то есть из текущей директории перейти в папку serverNodeJs и там будет этот Dockerfile,также делаем и для образа фронтенда
  script:
    - docker build -t euphoriaServerNodeJs ./serverNodeJsPostgreSql
    - docker build -t euphoriaClientReactJs ./client-reactjs

test-job:
  stage: test
  # в данном случае указываем команду для запуска контейнера на основе нашего образа(euphoriaServerNodeJs в данном случае),указываем --rm(это значит,что когда мы остановим потом этот контейнер,то он будет автоматически удален),чтобы этот контейнер удалился после прогона тестов в нашем ci cd пайплайне у гитлаба,также указываем еще флаг -v,чтобы видеть логи этого контейнера(этих тестов,в данном случае будет показывать просто версию при успешном тесте), командой docker run --rm reactjscicdgitlab npm run test -- --coverage --watchAll=false --forceExit запускаем наш контейнер для фронтенда и запускаем внутри него команду npm run test для прогона тестов
  script:
    - docker run --rm euphoriaServerNodeJs -v # указываем --rm,чтобы после выполнения команды этот контейнер удалился,убираем у них названия,чтобы не было ошибок,что такие контейнеры уже есть
    - docker run --rm euphoriaClientReactJs npm run test -- --coverage --watchAll=false --forceExit # обязательно добавляем к команде npm run test два минуса(-- , чтобы передать дальше параметры для jest(библиотеки тестирования)) и через пробел флаг --watchAll=false,чтобы при ошибке в тестах процесс стадии джобы в gitlab runner завершался как ошибка,иначе запуск тестов будет бесконечно грузиться,даже если они закончились и вывело ошибку,также можно добавить флаг --coverage(чтобы показалась таблица большего отчета по тестам и еще можно добавить флаг --forceExit,чтобы гарантированно указать,что скрипт тестов завершается и завершается стадия джобы в gitlab runner(хотя этот тег не обязателен,так как работает это тоже и просто с тегом --watchAll=false)),указываем --rm,чтобы после выполнения команды этот контейнер удалился,даже если тесты будут с ошибкой,делаем так,потому что если не указать это,то если будут ошибки в тестах,то команды ниже не выполнятся,соответственно не будут удалены эти контейнеры,убираем у них названия,чтобы не было ошибок,что такие контейнеры уже есть

deploy-job:
  stage: deploy
  # в данном случае указываем команду для запуска нашего docker compose(docker compose up),чтобы он запустил все контейнеры,указываем флаг -d,чтобы у нас контейнер не повис и запустился в режиме детач(detach,типа в фоновом режиме),чтобы он не блокировал консоль типа,потом вручную не придется удалять контейнеры эти,которые создал docker compose,так как при повторной команде docker compose up -d уже созданные контейнеры(которым мы указывали названия в файле docker-compose.yml) будут пересоздаваться(перезаписываться) и ошибок таких не будет
  script:
    - docker compose up -d