# лучше объединять контейнеры в единую сеть(чтобы контейнеры могли общаться между собой и обращаться к друг другу по названию сервиса(контейнера,который мы описываем ниже)),здесь ее и указываем,указываем название(типа любое) этой сети(dev в данном случае)
networks:
  dev:

# указываем сервисы(services),в них будем описывать все части нашего приложения,которые будем запускать в контейнерах,для каждого сервиса даем название(оно может быть любым),в данном случае,например,для бэкэнд контейнера указываем название backend
services:
  backend:
    # указываем образ контейнера в поле image,в данном случае указываем наш образ euphoriaServerNodeJs(мы его собирали в gitlab ci файле,название образа должно быть в нижнем регистре букв,иначе ошибка) с тегом latest,то есть самой последней версией,то есть самый последний созданный образ
    image: euphoriaservernodejs:latest
    # указываем имя контейнера,который будет запущен на основе нашего образа
    container_name: cont-euphoriaservernodejs
    # указваем порты,на которых будет запускаться контейнер этого нашего образа,то есть здесь первым портом указываем порт для локального компьютера(сервера),на котором будет запущен докер контейнер,а вторым указываем порт у самого докер контейнера
    ports:
      - 5000:5000
    # в данном случае этот бэкэнд зависит от базы данных PostgreSql,поэтому указываем поле depends_on в нем указываем поля(названия) контейнеров,которые мы описывали в этих сервисах(services),от которых зависит текущий сервис(контейнер),в нем указываем поле condition(условие) по которому проверяем,что сервис доступен, указываем ему значение service_healthy(это значит,что нужно проверять по healthcheck,который мы описали у этого сервиса базы данных),если не указать отдельное это условие,то по дефолту будет проверяться по запуску контейнера
    depends_on:
      dbPostgreSql:
        condition: service_healthy
    # указываем сеть,в которой этот контейнер работает,указываем название сети(dev в данном случае),которое мы создали выше в поле networks
    networks:
      - dev
    # указываем команду,которая будет запущена,когда будет запущен контейнер,указываем ее,чтобы запустить наше приложение,но так как мы указывали поле CMD в докер файле,чтобы была запущена команда node index.js для запуска нашего приложения,то здесь уже ее указывать не надо,поэтому этот код закомментируем
    # command: "node index.js"

  frontend:
    # указываем образ контейнера в поле image,в данном случае указываем наш образ euphoriaclientreactjs(мы его собирали в gitlab ci файле,название образа должно быть в нижнем регистре букв,иначе ошибка) с тегом latest,то есть самой последней версией,то есть самый последний созданный образ
    image: euphoriaclientreactjs:latest
    # указываем имя контейнера,который будет запущен на основе нашего образа
    container_name: cont-euphoriaclientreactjs
    # указваем порты,на которых будет запускаться контейнер этого нашего образа,то есть здесь первым портом указываем порт для локального компьютера(сервера),на котором будет запущен докер контейнер,а вторым указываем порт у самого докер контейнера
    ports:
      - 3000:3000
    # указываем сеть,в которой этот контейнер работает,указываем название сети(dev в данном случае),которое мы создали выше в поле networks
    networks:
      - dev
    # указываем от каких контейнеров зависит этот контейнер frontend,то есть указываем,чтобы контейнер frontend запускался только после того,как будут запущены эти контейнеры,которые мы указываем в depends_on(в данном случае это backend контейнер)
    depends_on:
      - backend
    # указываем команду,которая будет запущена,когда будет запущен контейнер,указываем ее,чтобы запустить тесты после запуска контейнера,в данном случае уже не надо указывать это,так как указываем прогон тестов в файле .gitlab-ci.yml
    # command: "npm run test"
  
  dbPostgreSql:
    # указываем образ контейнера в поле image,в данном случае для контейнера базы данных указываем образ как postgres(он будет скачан из докер хаба),также ему можно указать тег(типа версию) через двоеточие после postgres,но в данном случае указали так
    image: postgres
    # указываем параметры базы данных типа пользователя,пароля и тд(более подробные настройки есть на странице этого образа postgres в докер хабе),в данном случае указываем переменные окружения с помощью поля environment,указываем переменные для пароля,пользователя и названия самой базы данных,значение этих переменных можно описать в файле переменных окружения(для этого создали файл .env в корневой папке проекта с папками фронтенда и бэкэнда),в данном случае из этого файла .env будут браться эти переменные при запуске файла Docker-Compose
    environment:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_DB: ${DB_NAME}
      # POSTGRES_PORT: 5432
      # POSTGRES_HOST: dbPostgreSql 
    # в поле healthcheck проверяем работоспособность текущего сервиса,запущен ли он сейчас и тд(в данном случае бэкэнд сервис зависит от базы данных,и если база данных не запущена и не работает,а бэкэнд уже запустился,то будет ошибка),в поле test указываем команду для проверки работоспособности текущего сервиса, в данном случае для базы данных указываем первым элементом массива в какой консоли будет эта команда,а вторым саму команду pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} (это обычная команда для PostgreSql для проверки работоспособности),указываем interval(интервал,то есть время между следующим запросом к базе данных) в 10s(секунд),timeout(задержка между интервалом,то есть время на ответ от базы данных,если в течении этого времени база данных не ответит,то эта проверка будет считаться неудавшейся) в 5s и retries(повторных попыток запроса к базе данных на проверку работоспособности) 3
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 3
    # для базы данных типа PostgreSql нужно указывать вольюмы(volumes),чтобы данные базы данных не удалялись при удалении или закрытии контейнера,указываем поле volumes и ниже указываем элемент массива volumes с знаком -(типа минус) называем volume(в данном случае как db-data) и потом значение ему указываем через двоеточие без пробела как обычный путь до данных PostgreSql(в данном случае это /var/lib/postgresql/data)
    volumes: 
      - db_data:/var/lib/postgresql/data
    networks:
      - dev

# ниже указываем отдельное поле volumes где указываем такое же название,как указали для вольюма для базы данных,чтобы это работало
volumes:
  db_data: