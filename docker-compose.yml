# лучше объединять контейнеры в единую сеть(чтобы контейнеры могли общаться между собой и обращаться к друг другу по названию сервиса(контейнера,который мы описываем ниже)),здесь ее и указываем,указываем название(типа любое) этой сети(dev в данном случае)
networks:
  dev:

# указываем сервисы(services),в них будем описывать все части нашего приложения,которые будем запускать в контейнерах,для каждого сервиса даем название(оно может быть любым),в данном случае,например,для бэкэнд контейнера указываем название backend
services:
  # комментируем backend контейнер,так как закомментировали контейнер с базой данных,и бэкэнд контейнер запускается с ошибкой,что не может подключиться к базе данных,поэтому оставим в данном случае фронтенд контейнер
  # backend:
  #   # указываем образ контейнера в поле image,в данном случае указываем наш образ euphoriaServerNodeJs(мы его собирали в gitlab ci файле,название образа должно быть в нижнем регистре букв,иначе ошибка) с тегом latest,то есть самой последней версией,то есть самый последний созданный образ
  #   image: euphoriaservernodejs:latest
  #   # указываем имя контейнера,который будет запущен на основе нашего образа
  #   container_name: cont-euphoriaservernodejs
  #   # указваем порты,на которых будет запускаться контейнер этого нашего образа,то есть здесь первым портом указываем порт для локального компьютера(сервера),на котором будет запущен докер контейнер,а вторым указываем порт у самого докер контейнера
  #   ports:
  #     - 5000:5000

  #   # в данном случае не запускаем контейнер с базой данных,так как для этого нужно будет указывать конкретно ее хост,но мы сейчас с ней взаимодействуем на нашем локально компютере(то есть на localhost),поэтому для пайплайна ci cd не будем его запускать,так как не арендовали сервер(запускать так контейнеры нужно на арендованном сервере,чтобы стадия deploy в ci cd пайплайне разворачивала(и потом пересоздавала) контейнеры на арендованном сервере,но сейчас работаем на локальном компьютере и нужно взаимодействовать с базой данных postgresql локально на этом компьютере,поэтому этот код закомментируем)
  #   # в данном случае этот бэкэнд зависит от базы данных PostgreSql,поэтому указываем поле depends_on в нем указываем поля(названия) контейнеров,которые мы описывали в этих сервисах(services),от которых зависит текущий сервис(контейнер),в нем указываем поле condition(условие) по которому проверяем,что сервис доступен, указываем ему значение service_healthy(это значит,что нужно проверять по healthcheck,который мы описали у этого сервиса базы данных),если не указать отдельное это условие,то по дефолту будет проверяться по запуску контейнера
  #   # depends_on:
  #   #   dbPostgreSql:
  #   #     condition: service_healthy
  #   # указываем сеть,в которой этот контейнер работает,указываем название сети(dev в данном случае),которое мы создали выше в поле networks

  #   networks:
  #     - dev
    # указываем команду,которая будет запущена,когда будет запущен контейнер,указываем ее,чтобы запустить наше приложение,но так как мы указывали поле CMD в докер файле,чтобы была запущена команда node index.js для запуска нашего приложения,то здесь уже ее указывать не надо,поэтому этот код закомментируем
    # command: "node index.js"

  frontend:
    # указываем образ контейнера в поле image,в данном случае указываем наш образ euphoriaclientreactjs(мы его собирали в gitlab ci файле,название образа должно быть в нижнем регистре букв,иначе ошибка) с тегом latest,то есть самой последней версией,то есть самый последний созданный образ
    image: euphoriaclientreactjs:latest
    # указываем имя контейнера,который будет запущен на основе нашего образа
    container_name: cont-euphoriaclientreactjs
    # указваем порты,на которых будет запускаться контейнер этого нашего образа,то есть здесь первым портом указываем порт для локального компьютера(сервера),на котором будет запущен докер контейнер,а вторым указываем порт у самого докер контейнера
    ports:
      - 3000:3000
    # указываем сеть,в которой этот контейнер работает,указываем название сети(dev в данном случае),которое мы создали выше в поле networks
    networks:
      - dev
    
    # бэкэнд контейнер тоже закоментировали
    # указываем от каких контейнеров зависит этот контейнер frontend,то есть указываем,чтобы контейнер frontend запускался только после того,как будут запущены эти контейнеры,которые мы указываем в depends_on(в данном случае это backend контейнер)
    # depends_on:
    #   - backend
    # указываем команду,которая будет запущена,когда будет запущен контейнер,указываем ее,чтобы запустить тесты после запуска контейнера,в данном случае уже не надо указывать это,так как указываем прогон тестов в файле .gitlab-ci.yml
    # command: "npm run test"
  
# в данном случае пока не будем запускать контейнер базы данных,так как для этого нужно будет указывать конкретно ее хост,но мы сейчас с ней взаимодействуем на нашем локально компютере(то есть на localhost),поэтому для пайплайна ci cd не будем его запускать,так как не арендовали сервер(запускать так контейнеры нужно на арендованном сервере,чтобы стадия deploy в ci cd пайплайне разворачивала(и потом пересоздавала) контейнеры на арендованном сервере,но сейчас работаем на локальном компьютере и нужно взаимодействовать с базой данных postgresql локально на этом компьютере,поэтому этот код закомментируем)
#   dbPostgreSql:
#     # указываем образ контейнера в поле image,в данном случае для контейнера базы данных указываем образ как postgres(он будет скачан из докер хаба),также ему можно указать тег(типа версию) через двоеточие после postgres,но в данном случае указали так
#     image: postgres
#     # указываем параметры базы данных типа пользователя,пароля и тд(более подробные настройки есть на странице этого образа postgres в докер хабе),в данном случае указываем переменные окружения с помощью поля environment,указываем переменные для пароля,пользователя и названия самой базы данных,значение этих переменных можно описать в файле переменных окружения(для этого создали файл .env в корневой папке проекта с папками фронтенда и бэкэнда),в данном случае из этого файла .env будут браться эти переменные при запуске файла Docker-Compose
#     environment:
#       POSTGRES_PASSWORD: ${DB_PASSWORD}
#       POSTGRES_USER: ${DB_USER}
#       POSTGRES_DB: ${DB_NAME}

#       # эти параметры порта и хоста не обязательно указывать отдельно,так как по дефолту postgresql занимает порт 5432 внутри контейнера,а хост этой базы данных postgresql мы указали для sequelize на бэкэнде как название этого сервиса(контейнера,в данном случае название dbPostgreSql) с базой данных postgreSql
#       # POSTGRES_PORT: 5432
#       # POSTGRES_HOST: dbPostgreSql 

#     # в поле healthcheck проверяем работоспособность текущего сервиса,запущен ли он сейчас и тд(в данном случае бэкэнд сервис зависит от базы данных,и если база данных не запущена и не работает,а бэкэнд уже запустился,то будет ошибка),в поле test указываем команду для проверки работоспособности текущего сервиса, в данном случае для базы данных указываем первым элементом массива в какой консоли будет эта команда,а вторым саму команду pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} (это обычная команда для PostgreSql для проверки работоспособности),указываем interval(интервал,то есть время между следующим запросом к базе данных) в 10s(секунд),timeout(задержка между интервалом,то есть время на ответ от базы данных,если в течении этого времени база данных не ответит,то эта проверка будет считаться неудавшейся) в 5s и retries(повторных попыток запроса к базе данных на проверку работоспособности) 3
#     healthcheck:
#       test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
#       interval: 10s
#       timeout: 5s
#       retries: 3
#     # для базы данных типа PostgreSql нужно указывать вольюмы(volumes),чтобы данные базы данных не удалялись при удалении или закрытии контейнера,указываем поле volumes и ниже указываем элемент массива volumes с знаком -(типа минус) называем volume(в данном случае как db-data) и потом значение ему указываем через двоеточие без пробела как обычный путь до данных PostgreSql(в данном случае это /var/lib/postgresql/data)
#     volumes: 
#       - db_data:/var/lib/postgresql/data
#     # лучше указывать тоже для базы данных ту же сеть,в которой находятся контейнеры бэкэнда и фронтенда(сеть с названием dev в данном случае)
#     networks:
#       - dev

# # ниже указываем отдельное поле volumes где указываем такое же название,как указали для вольюма для базы данных,чтобы это работало
# volumes:
#   db_data: