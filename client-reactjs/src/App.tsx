// лучше создать, подключить git репозиторий в проект,сделать первый commit и push данных в git до того,как создали папку с фронтендом на react js,иначе могут быть ошибки(могут и не быть) сохранений git папки всего проекта и git папки самого фронтенда на react js,также здесь будем использовать gitlab для ci cd пайплайна,поэтому нужно также подключить gitlab,чтобы туда также пушились изменения в коде,поэтому кроме добавления origin для гитхаба,нужно добавить еще origin для гитлаба, командой git remote set-url --add origin(origin здесь это имя для репозитория(вместо его url) и лучше создать 2 разных имени для гитхаб репозитория и гитлаб,чтобы потом не путаться,но в данном случае оставили название origin,чтобы комнадой git push -u origin и название ветки,пушилось сразу в два репозитория с этим именем origin,командой git remote show можно увидеть имена для подключенных удаленных репозиториев(типа на гитхабе или гитлабе)) и ссылка на гитлаб репозиторий,добавляет отслеживание репозитория гитлаба и возможность пушить изменения еще и в гитлаб репозиторий,команда git push -u origin master пушит изменения в репозиторий для ветки master,слово origin здесь - это просто имя репозитория(вместо его url),а флаг -u устанавливает отслеживание ветки,которую мы указали(master в данном случае),чтобы потом можно было использовать команду git push и не указывать уже какую ветку пушить,так как до этого ее так указали,но в первый раз при пуше в репозиторий гитлаба нужно будет в всплывающем окне войти в свой аккаунт гитлаба,чтобы запушились изменения,или можно вместо этого сразу подключить репозиторий гитлаба командой git remote add origin и ссылка на гитлаб репозиторий,а потом уже командой git remote set-url --add origin и ссылка на гитхаб репозиторий добавить url репозитория гитхаба,но в этом url тогда лучше будет указать токен доступа,который можно создать в настройках профиля developer settings,и там создать access token(classic),выбрать параметры доступа и сгенерировать этот ключ,потом его в этом url репозитория указать и таким образом подключиться к репозитории гитхаба,но лучше сразу гитхаб подключить,а потом гитлаб,также чтобы вручную в гитлабе не мержить(merge,сливать вместе) новую ветку master(так как по дефолту главная ветка в гитлаб репозитории называется main),то нужно в настройках в repository указать default branch(дефолтную главную ветку) на master(но нужно,чтобы эта ветка master была сейчас активна,и ожидала типа мержа,чтобы смержиться(merge) с главной веткой main)
// ,тогда ее можно будет увидеть и выбрать как главную ветку,также для ci cd не обязательно заново регистрировать новый раннер для этого нового репозитория,если до этого уже регистрировали раннер и создавали его на локальном компьютере,поэтому в данном случае просто просто в настройках ci cd во вкладке runners нажимаем enable runner for this project(то есть включить этот раннер для этого проекта(репозитория)) возле созданного ранее раннера gitlab runner,и после этого нужно вручную добавить файл .gitlab-ci.yml в корневую папку проекта с папками фронтенда и бэкэнда,также во вкладке build ci/cd нужно убрать галочку с настройки Enable instance runners for this project,чтобы не запускались раннеры гитлаба для пайплайна,как минимум потому,что они требуют верификацию личности(подтвердить карту),и теперь после этого когда будем пушить изменения в коде на гитхаб и гитлаб командой git push,то будет автоматически срабатывать этот наш ci cd пайплайн(мы описали его в файле .gitlab-ci.yml) в репозитории гитлаба

// указываем команду в корневой папке проекта в терминале npx create-react-app --template(шаблон) typescript(с typescript),чтобы развернуть шаблонное приложение react js с typescript,потом там будет вопрос,что нужно установить дополнительный пакет новой версии create-react-app,указываем y и enter и это установится,устанавливаем npm i react-router-dom для работы с роутингом страниц(маршрутами страниц), устанавливаем библиотеку npm i react-slider --force,указываем --force,чтобы установить эту библиотеку через силу,так как для версии react 19,выдает ошибку при установке этой библиотеки (в терминале в папку с фронтенд приложением(сайтом),в данном случае в папку client-reactjs),чтобы сделать input range(инпут с ползунками), устанавливаем типы для библиотеки react-slider npm install --save-dev @types/react-slider --force( указываем --force,чтобы установить эту библиотеку через силу,так как для версии react 19,выдает ошибку при установке этой библиотеки),устанавливаем эти типы,чтобы не было ошибки у typescript при импорте ReactSlider, устанавливаем react query с помощью команды в терминале npm i @tanstack/react-query(чтобы лучше и удобней обрабатывать запросы на сервер),устанавливаем npm i axios(чтобы делать запросы на сервер),теперь нужно устанавливать все эти библиотеки через силу с помощью --force(указываем это в конце каждой команды для установки библиотеки),чтобы они устанавливались,иначе выдает ошибку с ReactSlider,что он устарел, и это не дает установить остальные библиотеки,устанавливаем npm i swiper(swiper для слайдера) также с --force, устанавливаем npm i @reduxjs/toolkit react-redux для работы с redux toolkit также с --force

// формат картинок svg можно изменять до любого размера без потери качества и он меньше весит,чем png формат,лучше использовать svg картинки для всяких небольших картинок,когда задний фон картинки не имеет значения

import { BrowserRouter, Navigate, Route, Routes } from "react-router-dom";
import Header from "./components/Header";
import HomePage from "./pages/HomePage";
import Catalog from "./pages/Catalog";
import ProductItemPage from "./pages/ProductItemPage";
import AboutUs from "./pages/AboutUs";
import UserPage from "./pages/UserPage";
import Cart from "./pages/Cart";


function App() {
  return (
    <>
      {/* оборачиваем все в BrowserRouter для роутинга страниц(маршрутов страниц),а также чтобы работал наш компонент <ScrollToTop/>,позже будем указывать конкретные маршруты с помощью <Routes> */}
      <BrowserRouter>

        {/* здесь еще надо будет сделать ScrollToTop и враппер,чтобы прижать хедер и футер */}
        <Header/>

        <Routes>
          <Route path="/" element={<HomePage/>}/> {/* указываем путь до страницы <HomePage/> как / */}
          
          <Route path="/catalog" element={<Catalog/>}/> 

          <Route path="/catalog/:id" element={<ProductItemPage/>}/> {/* указываем после /catalog/ :id,для динамического id,чтобы потом открывалась отдельная страница товара по конкретному id  */} 

          <Route path="/aboutUs" element={<AboutUs/>}/> 

          <Route path="/cart" element={<Cart/>}/> 

          <Route path="/userPage" element={<UserPage/>}/> 

          <Route path="/*" element={<Navigate to="/" />}/>  {/* если пользователь введет в url несуществующую страницу,то его перекинет на главную(в данном случае если пользователь введет в url несуществующую страницу( в path= "/*" - любое значение,кроме тех,которые уже есть в Route), то его перекинет на главную страницу с помощью Navigate(импортировали этот модуль из библиотеки react-router-dom) и в to= указываем на какую страницу(на какой из существующих Route(маршрутов)) перекинуть пользователя) */}
          
        </Routes>

      </BrowserRouter>
    </>
  );
}

export default App;
