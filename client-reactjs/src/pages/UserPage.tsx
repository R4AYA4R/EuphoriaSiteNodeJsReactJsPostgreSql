import axios, { AxiosResponse } from "axios";
import SectionUnderTop from "../components/SectionUnderTop";
import UserPageFormComponent from "../components/UserPageFormComponent";
import { useActions } from "../hooks/useActions";
import { useTypedSelector } from "../hooks/useTypedSelector";
import { AuthResponse, IDeleteFileResponse, IDescImages, IProduct, IUploadFileResponse } from "../types/types";
import { ChangeEvent, FormEvent, RefObject, useEffect, useRef, useState } from "react";
import AuthService from "../service/AuthService";
import { useIsOnScreen } from "../hooks/useIsOnScreen";
import $api from "../http/http";


const UserPage = () => {

    const { isAuth, user, isLoading } = useTypedSelector(state => state.userSlice); // указываем наш слайс(редьюсер) под названием userSlice и деструктуризируем у него поле состояния isAuth и тд,используя наш типизированный хук для useSelector

    const { setLoadingUser, authorizationForUser, logoutUser, setUser } = useActions();  // берем actions для изменения состояния пользователя у слайса(редьюсера) userSlice у нашего хука useActions уже обернутые в диспатч,так как мы оборачивали это в самом хуке useActions

    const [tab, setTab] = useState('Dashboard');

    const [inputNameAccSettings, setInputNameAccSettings] = useState('');

    const [inputEmailAccSettings, setInputEmailAccSettings] = useState('');

    const [errorAccSettings, setErrorAccSettings] = useState('');


    const [inputCurrentPassword, setInputCurrentPassword] = useState('');

    const [inputNewPassword, setInputNewPassword] = useState('');

    const [inputConfirmPassword, setInputConfirmPassword] = useState('');

    const [hideInputCurrentPass, setHideInputCurrentPass] = useState(true);

    const [hideInputNewPass, setHideInputNewPass] = useState(true);

    const [hideInputConfirmPass, setHideInputConfirmPass] = useState(true);

    const [errorChangePass, setErrorChangePass] = useState('');


    const [inputProductName, setInputProductName] = useState('');

    const [textareaProductDesc, setTextareaProductDesc] = useState('');

    const [activeSelectBlockCategory, setActiveSelectBlockCategory] = useState(false);

    const [selectBlockCategoryValue, setSelectBlockCategoryValue] = useState(''); // состояние для значения селекта сортировки товаров по рейтингу и тд

    const [activeSelectBlockType, setActiveSelectBlockType] = useState(false);

    const [selectBlockTypeValue, setSelectBlockTypeValue] = useState(''); // состояние для значения селекта сортировки товаров по рейтингу и тд

    const [sizesMass, setSizesMass] = useState<string[]>([]); // массив для выбранных размеров для товара

    const [inputPriceValue, setInputPriceValue] = useState(1);

    const [inputPriceDiscountValue, setInputPriceDiscountValue] = useState(0);

    const [inputFileMainImage, setInputFileMainImage] = useState<File | null>(); // состояние для файла картинки продукта,которые пользователь выберет в инпуте для файлов,указываем тут тип any,чтобы не было ошибки,в данном случае указываем тип как File или null

    const [imgPath, setImgPath] = useState('');  // состояние для пути картинки,который мы получим от сервера,когда туда загрузим картинку(чтобы отобразить выбранную пользователем(админом) картинку уже полученную от сервера, когда туда ее загрузим)

    // в данном случае уже не используем это,так как используем просто объект картинки на основе Image() (new Image())
    // const newMainProductImage = useRef<HTMLImageElement>(null); // используем useRef для подключения к html тегу картинки нового товара,чтобы взять у него ширину и проверить ее,в generic типе этого useRef указываем,что в этом useRef будет HTMLImageElement(то есть картинка)

    const inputMainImage = useRef<HTMLInputElement>(null); // указываем ссылку для инпута файлов главной картинки для товара

    const [descImages, setDescImages] = useState<IDescImages[]>([]); // состояние массива объектов картинок описания,указываем ему тип в generic на основе нашего интерфейса IDescImage,и указываем,что это массив [],по дефолту делаем ему значение пустого массива

    const inputDescImages = useRef<HTMLInputElement>(null); // указываем ссылку для инпута файлов картинки описания для товара

    const [canDelete, setCanDelete] = useState(false); // указываем состояние,чтобы можно было удалять элемент из состояния массива descImages,чтобы не циклилось удаление

    const [errorNewProductForm, setErrorNewProductForm] = useState('');

    const [errorNewProductFormForImg, setErrorNewProductFormForImg] = useState(''); // состояние ошибки для картинки для формы админа 

    const selectBlockCategoryItemHandler = (category: string) => {

        setSelectBlockCategoryValue(category); // изменяем состояние setSelectBlockCategoryValue на значение category(параметр этой функции)

        setActiveSelectBlockCategory(false); // изменяем состояние setActiveSelectBlockCategory на значение false,то есть убираем появившийся селект блок
    }

    const selectBlockTypeItemHandler = (type: string) => {

        setSelectBlockTypeValue(type); // изменяем состояние setSelectBlockTypeValue на значение type(параметр этой функции)

        setActiveSelectBlockType(false); // изменяем состояние setActiveSelectBlockType на значение false,то есть убираем появившийся селект блок
    }

    // функция для удаления файла главной картинки нового товара на сервере,указываем тип imageName как string | undefined,так как иначе показывает ошибку,что нельзя передать параметр этой функции,если значение этого параметра undefined
    const deleteMainImageRequest = async (imageName: string | undefined) => {

        // оборачиваем в try catch для отлавливания ошибок
        try {

            const response = await axios.delete<IDeleteFileResponse>(`${process.env.REACT_APP_BACKEND_URL}/api/deleteImage/${imageName}`); // делаем запрос на сервер для удаления файла(картинки в данном случае) на сервере и указываем в ссылке на эндпоинт параметр imageName,чтобы на бэкэнде его достать,здесь уже используем обычный axios вместо нашего axios с определенными настройками ($api в данном случае),так как на бэкэнде у этого запроса на удаление файла с сервера уже не проверяем пользователя на access токен,так как проверяем это у запроса на загрузку файла на сервер(поэтому будет и так понятно,валидный(годен ли по сроку годности еще) ли access токен у пользователя или нет),указываем в generic тип данных,которые придут от сервера после удаления картинки(наш тип IDeleteFileResponse в данном случае)

            console.log(response.data); // выводим в логи ответ от сервера

        } catch (e: any) {

            setErrorNewProductFormForImg(e.response?.data?.message); // показываем ошибку в форме создания нового товара для админа

        }

    }

    const deleteMainImageRequestByBtn = async (imageName: string | undefined) => {

        // оборачиваем в try catch для отлавливания ошибок
        try {

            const response = await axios.delete<IDeleteFileResponse>(`${process.env.REACT_APP_BACKEND_URL}/api/deleteImage/${imageName}`); // делаем запрос на сервер для удаления файла(картинки в данном случае) на сервере и указываем в ссылке на эндпоинт параметр imageName,чтобы на бэкэнде его достать,здесь уже используем обычный axios вместо нашего axios с определенными настройками ($api в данном случае),так как на бэкэнде у этого запроса на удаление файла с сервера уже не проверяем пользователя на access токен,так как проверяем это у запроса на загрузку файла на сервер(поэтому будет и так понятно,валидный(годен ли по сроку годности еще) ли access токен у пользователя или нет),указываем в generic тип данных,которые придут от сервера после удаления картинки(наш тип IDeleteFileResponse в данном случае)

            console.log(response.data); // выводим в логи ответ от сервера

            setImgPath(''); // изменяем состояние imgPath(пути картинки) на пустую строку,чтобы картинка не показывалась,если она была удалена с сервера(иначе картинка показывается,даже если она удалена с сервера)

            setInputFileMainImage(null); // изменяем состояние для инпута файла главной картинки для нового товара,указываем ему значение как null,чтобы когда админ удалил эту картинку,то это состояние для файла картинки становилось null и имя удаленного файла картинки не показывалось

            // если inputMainImage.current true(то есть inputMainImage.current есть),делаем эту проверку,так как выдает ошибку,что inputMainImage.current может быть null
            if (inputMainImage.current) {

                inputMainImage.current.value = ''; // изменяем текущее значение у inputMainImage.current(инпута файла для главной картинки для товара) на пустую строку,то есть очищаем этот инпут для файлов,чтобы потом при удалении выбранной картинки очищать значение этого инпута,иначе,если выбрать картинку,потом ее удалить,а потом опять выбрать сразу же эту картинку в этом инпуте файлов,то она не будет выбираться,так как не будет срабатывать onChange для этого инпута,так как в этом инпуте будет еще сохранено предыдущее значение этого файла картинки,можно очищать значение для инпута файлов с помощью useRef,как это сделали сейчас

            }

            setErrorNewProductFormForImg(''); // убираем ошибку(это состояние конкретно для ошибки,связанной с картинкой) формы создания нового товара(чтобы если до этого пользователь(админ) выбрал неправильный файл(или ошибку,что такой файл уже существует) и получил ошибку,то при повторном выборе файла эта ошибка убиралась)

        } catch (e: any) {

            setErrorNewProductFormForImg(e.response?.data?.message); // показываем ошибку в форме создания нового товара для админа

        }

    }

    // фукнция для удаления картинки описания для товара на сервере для удаления по кнопке
    const deleteDescImageRequestByBtn = async (imageName: string | undefined) => {

        // оборачиваем в try catch для отлавливания ошибок
        try {

            const response = await axios.delete<IDeleteFileResponse>(`${process.env.REACT_APP_BACKEND_URL}/api/deleteImage/${imageName}`); // делаем запрос на сервер для удаления файла(картинки в данном случае) на сервере и указываем в ссылке на эндпоинт параметр imageName,чтобы на бэкэнде его достать,здесь уже используем обычный axios вместо нашего axios с определенными настройками ($api в данном случае),так как на бэкэнде у этого запроса на удаление файла с сервера уже не проверяем пользователя на access токен,так как проверяем это у запроса на загрузку файла на сервер(поэтому будет и так понятно,валидный(годен ли по сроку годности еще) ли access токен у пользователя или нет),указываем в generic тип данных,которые придут от сервера после удаления картинки(наш тип IDeleteFileResponse в данном случае)

            console.log(response.data); // выводим в логи ответ от сервера

            setDescImages((prev) => [...prev.filter(i => i.name !== imageName)]); // изменяем состояние массива descImages,разворачиваем предыдущий массив (...prev) и фильтруем его,указываем,что оставляем все элементы в массиве,у которых поле name не равно imageName,то есть удаляем из этого массива элемент той картинки,которую удалил админ по кнопке и этот новый отфильтрованный массив разворачиваем в новый [],то есть сразу предыдущий(текущий) массив(prev) фильтруем,а потом уже этот отфильтрованный массив разворачиваем в новый массив []

            // если inputDescImages.current true(то есть inputDescImages.current есть),делаем эту проверку,так как выдает ошибку,что inputDescImages.current может быть null
            if (inputDescImages.current) {

                inputDescImages.current.value = ''; // изменяем текущее значение у inputDescImages.current(инпута файла для картинки описания для товара) на пустую строку,то есть очищаем этот инпут для файлов,чтобы потом при удалении выбранной картинки очищать значение этого инпута,иначе,если выбрать картинку,потом ее удалить,а потом опять выбрать сразу же эту картинку в этом инпуте файлов,то она не будет выбираться,так как не будет срабатывать onChange для этого инпута,так как в этом инпуте будет еще сохранено предыдущее значение этого файла картинки,можно очищать значение для инпута файлов с помощью useRef,как это сделали сейчас

            }

            setErrorNewProductFormForImg(''); // убираем ошибку(это состояние конкретно для ошибки,связанной с картинкой) формы создания нового товара(чтобы если до этого пользователь(админ) выбрал неправильный файл(или ошибку,что такой файл уже существует) и получил ошибку,то при повторном выборе файла эта ошибка убиралась)

        } catch (e: any) {

            setErrorNewProductFormForImg(e.response?.data?.message); // показываем ошибку в форме создания нового товара для админа

        }

    }

    // функция для удаления папки checkStatic на бэкэнде
    const deleteCheckStatic = async () => {

        // оборачиваем в try catch для обработки ошибок
        try {

            const response = await axios.delete(`${process.env.REACT_APP_BACKEND_URL}/api/deleteCheckStatic`);  // делаем delete запрос на удаление папки checkStatic на бэкэнде,используем здесь обычный axios,а не наш $api(наш инстанс axios с определенными настройками),так как здесь не нужна проверка на авторизацию пользователя

            console.log(response);

        } catch (e: any) {

            console.log(e.response?.data?.message); // выводим ошибку в логи

        }

    }

    // при редндеринге(запуске) страницы и при изменении состояния пользователя user будет отработан код в этом useEffect
    useEffect(() => {

        // если user.role равно 'ADMIN',то есть роль у пользователя 'ADMIN',то есть пользователь сейчас авторизован как админ,делаем эту проверку,чтобы шел запрос на удаление папки checkStatic только если пользователь авторизован как админ
        if (user.role === 'ADMIN') {

            deleteCheckStatic(); // вызываем нашу функцию для удаления папки checkStatic на бэкэнде,это тестовая папка,которая создается,когда админ выбирает картинки для нового товара,удаляем ее,при редндеринге(запуске) страницы и при изменении состояния пользователя user,чтобы если админ выбрал картинку для товара,не сохранил товар,а обновил страницу,то чтобы он потом мог выбрать эту же картинку,чтобы не выдавало ошибку,что такой файл уже существует

        }

    }, [user])

    // указываем функцию для добавления и удаления размеров в массив состояния sizes
    const addSizes = (itemSize: string) => {

        // если в массиве sizesMass нету элемента,равного значению itemSize(параметр этой функции)
        if (!sizesMass.some(size => size === itemSize)) {

            // изменянем состояние sizesMass,возвращаем новый массив,куда разворачиваем предыдущий(текущий) массив(...prev) и добавляем в него новый элемент itemSize,не используем здесь типа sizesMass.push(),так как тогда обновление состояние sizesMass будет не сразу,а ставится в очередь на обновление и это будет не правильно работать,а когда мы используем prev(текущее состояние),то тогда мы работаем уже точно с текущим состоянием массива,и он будет обновлен сразу
            setSizesMass((prev) => [...prev, itemSize]);


        } else {

            // в другом случае,если этот элемент(itemSize) уже есть,то оставляем все элементы в массиве sizes,которые не равны значению itemSize,то есть удаляем этот элемент itemSize из массива sizes
            setSizesMass((prev) => prev.filter(size => size !== itemSize));

        }


    }


    // фукнция для запроса на сервер на изменение информации пользователя в базе данных,лучше описать эту функцию в сервисе(отдельном файле для запросов типа AuthService),например, но в данном случае уже описали здесь,также можно это сделать было через useMutation с помощью react query(tanstack query),но так как мы в данном случае обрабатываем ошибки от сервера вручную,то сделали так
    const changeAccInfoInDb = async (userId: number, name: string, email: string) => {

        return $api.put('/changeAccInfo', { userId, name, email }); // возвращаем put запрос на сервер на эндпоинт /changeAccInfo для изменения данных пользователя и передаем вторым параметром объект с полями,используем здесь наш axios с определенными настройками,которые мы задали ему в файле http,чтобы правильно работали запросы на authMiddleware на проверку на access токен на бэкэнде,чтобы когда будет ошибка от бэкэнда от authMiddleware,то будет сразу идти повторный запрос на /refresh на бэкэнде для переобновления access токена и refresh токена(refresh и access токен будут обновляться только если текущий refresh токен еще годен по сроку годности,мы это прописали в функции у эндпоинта /refresh на бэкэнде) и опять будет идти запрос на изменение данных пользователя в базе данных(на /changeAccInfo в данном случае) но уже с переобновленным access токеном,который теперь действителен(это чтобы предотвратить доступ к аккаунту мошенникам,если они украли аккаунт,то есть если access токен будет не действителен уже,то будет запрос на /refresh для переобновления refresh и access токенов, и тогда у мошенников уже будут не действительные токены и они не смогут пользоваться аккаунтом,но если текущий refresh токен тоже будет не действителен,то будет ошибка,и пользователь не сможет получить доступ к этой функции(изменения данных пользователя в данном случае),пока заново не войдет в аккаунт)

    }

    // фукнция для запроса на сервер на изменение пароля пользователя в базе данных
    const changeAccPassInDb = async (userId: number, currentPass: string, newPass: string) => {

        return $api.put('/changeAccPass', { userId, currentPass, newPass }); // возвращаем put запрос на сервер на эндпоинт /changeAccPass для изменения данных пользователя и передаем вторым параметром объект с полями,используем здесь наш axios с определенными настройками,которые мы задали ему в файле http,чтобы правильно работали запросы на authMiddleware на проверку на access токен на бэкэнде,чтобы когда будет ошибка от бэкэнда от authMiddleware,то будет сразу идти повторный запрос на /refresh на бэкэнде для переобновления access токена и refresh токена(refresh и access токен будут обновляться только если текущий refresh токен еще годен по сроку годности,мы это прописали в функции у эндпоинта /refresh на бэкэнде) и опять будет идти запрос на изменение пароля пользователя в базе данных(на /changePass в данном случае) но уже с переобновленным access токеном,который теперь действителен(это чтобы предотвратить доступ к аккаунту мошенникам,если они украли аккаунт,то есть если access токен будет не действителен уже,то будет запрос на /refresh для переобновления refresh и access токенов, и тогда у мошенников уже будут не действительные токены и они не смогут пользоваться аккаунтом,но если текущий refresh токен тоже будет не действителен,то будет ошибка,и пользователь не сможет получить доступ к этой функции(изменения данных пользователя в данном случае),пока заново не войдет в аккаунт)

    }

    const checkAuth = async () => {

        setLoadingUser(true);

        // оборачиваем в try catch для отлавливания ошибок
        try {

            // здесь используем уже обычный axios,указываем тип в generic,что в ответе от сервера ожидаем наш тип данных AuthResponse, указываем url до эндпоинта /refresh на бэкэнде(в данном случае вынесли нашу переменную основного url до бэкэнда REACT_APP_BACKEND_URL в .env файле,это основной url до бэкэнда) и /api,то есть уже конкретный url до нашего роутера на бэкэнде на бэкэнде и через / указываем refresh(это тот url,где мы выдаем access и refresh токены на бэкэнде),и вторым параметром указываем объект опций,указываем поле withCredentials true(чтобы автоматически с запросом отправлялись cookies)
            const response = await axios.get<AuthResponse>(`${process.env.REACT_APP_BACKEND_URL}/api/refresh`, { withCredentials: true }); // в переменную response здесь будут помещены 2 токена(access и refresh) и поле user с типом данных на основе нашего интерфейса IUser,если запрос прошел успешно

            console.log(response.data);

            authorizationForUser(response.data);  // вызываем нашу функцию(action) для изменения состояния пользователя и передаем туда response.data(в данном случае это объект с полями accessToken,refreshToken и user,которые пришли от сервера)

        } catch (e: any) {

            console.log(e.response?.data?.message); // если была ошибка,то выводим ее в логи,берем ее из ответа от сервера из поля message из поля data у response у e

        } finally {

            // в блоке finally будет выполнен код в независимости от try catch(то есть в любом случае,даже если будет ошибка)
            setLoadingUser(false); // изменяем поле isLoading состояния пользователя в userSlice на false(то есть загрузка закончена)

        }

    }

    // при запуске сайта(в данном случае при рендеринге этого компонента,то есть этой страницы) будет отработан код в этом useEffect
    useEffect(() => {

        // если localStorage.getItem('token') true,то есть по ключу token в localStorage что-то есть,то есть пользователь уже когда-то регистрировался или авторизовывался и у него уже есть refresh токен в cookies
        if (localStorage.getItem('token')) {

            checkAuth(); // вызываем нашу функцию checkAuth(),которую описали выше для проверки авторизован ли пользователь

        }

        console.log(user.userName);
        console.log(isAuth);

    }, [])

    // const sectionTopRef = useRef<HTMLElement>(null); // создаем ссылку на html элемент и помещаем ее в переменную sectionTopRef,указываем тип в generic этому useRef как HTMLElement(иначе выдает ошибку),указываем в useRef null,так как используем typeScript

    // const onScreen = useIsOnScreen(sectionTopRef as RefObject<HTMLElement>); // вызываем наш хук useIsOnScreen(),куда передаем ссылку на html элемент(в данном случае на sectionTop),указываем тип этой ссылке на html элемент как RefObject<HTMLElement> (иначе выдает ошибку),и этот хук возвращает объект состояний,который мы помещаем в переменную onScreen,вторым параметром передаем в наш хук переменную isLoading,в данном случае она для отслеживания первоначальной загрузки данных пользователя,внутри хука отслеживаем этот параметр isLoading,и,если он равен false(или другое пустое значение),то только тогда начинаем следить за html элементом,чтобы показать анимацию,иначе,если не отслеживать эту загрузку,то intersectionObserver будет выдавать ошибку,что такого html элемента на странице не найдено,так как в это время будет показан только лоадер,для отслеживания загрузки данных пользователя,в данном случае


    // функция для выхода из аккаунта
    const logout = async () => {

        // оборачиваем в try catch,чтобы отлавливать ошибки 
        try {

            await AuthService.logout(); // вызываем нашу функцию logout() у AuthService

            logoutUser(); // вызываем нашу функцию(action) для изменения состояния пользователя для выхода из аккаунта и в данном случае не передаем туда ничего

            setTab('Dashboard');  // изменяем состояние таба на dashboard то есть показываем секцию dashboard(в данном случае главный отдел пользователя),чтобы при выходе из аккаунта и входе обратно у пользователя был открыт главный отдел аккаунта,а не настройки или последний отдел,который пользователь открыл до выхода из аккаунта

            // очищаем поля инпутов форм для изменения данных пользователя
            setInputEmailAccSettings(''); // изменяем состояние инпута почты на пустую строку,чтобы когда пользователь выходил из аккаунта очищался инпут почты,иначе,когда пользователь выйдет из аккаунта и войдет обратно,то в инпуте почты может быть текст,который он до этого там вводил

            setInputNameAccSettings(''); // изменяем состояние инпута имени на пустую строку,чтобы когда пользователь выходил из аккаунта очищался инпут имени,иначе,когда пользователь выйдет из аккаунта и войдет обратно,то в инпуте имени может быть текст,который он до этого там вводил

            setErrorAccSettings(''); // изменяем состояние ошибки формы изменения данных пользователя на пустую строку,чтобы когда пользователь выходил из аккаунта убиралась ошибка,даже если она там была,иначе,когда пользователь выйдет из аккаунта и войдет обратно,то может показываться ошибка,которую пользователь до этого получил

            setErrorChangePass('');  // изменяем состояние ошибки в форме для изменения пароля пользователя на пустую строку,то есть убираем ошибку 

            // изменяем состояния инпутов на пустые строки(то есть убираем у них значения)
            setInputCurrentPassword('');
            setInputNewPassword('');
            setInputConfirmPassword('');

            // изменяем значения состояний для типов инпутов(чтобы менять инпутам тип на password или text при нажатии на кнопку скрытия или показа пароля) у формы для изменения пароля пользователя,чтобы когда пользователь выходил из аккаунта эти состояния опять принимали дефолтное значение(то есть скрывали текст пароля изначально),иначе,когда пользователь выйдет из аккаунта и войдет обратно,то могут по-разному отображаться инпуты для паролей,какие-то скрыты,какие-то открыты,в зависимости от того,что пользователь до этого нажимал
            setHideInputCurrentPass(true);
            setHideInputNewPass(true);
            setHideInputConfirmPass(true);


            // если user.role равно 'ADMIN',то есть роль у пользователя 'ADMIN',то есть пользователь сейчас авторизован как админ,делаем эту проверку,чтобы шел запрос на удаление папки checkStatic только если пользователь авторизован как админ
            if (user.role === 'ADMIN') {

                deleteCheckStatic(); // вызываем нашу функцию для удаления папки checkStatic на бэкэнде,это тестовая папка,которая создается,когда админ выбирает картинки для нового товара,удаляем ее,при редндеринге(запуске) страницы и при изменении состояния пользователя user,чтобы если админ выбрал картинку для товара,не сохранил товар,а обновил страницу,то чтобы он потом мог выбрать эту же картинку,чтобы не выдавало ошибку,что такой файл уже существует,удаляем эту папку еще и при выходе из аккаунта,чтобы если админ выбрал картинки для товара,не сохранил товар,вышел из аккаунта,и зашел обратно без обновления страницы,то чтобы это нормально работало и админ мог опять выбирать те же картинки

            }

            // очищаем инпуты формы создания нового товара
            setInputProductName('');
            setSelectBlockCategoryValue('');
            setSelectBlockTypeValue('');
            setTextareaProductDesc('');
            setSizesMass([]); // очищаем массив выбранных размеров для нового товара
            setInputPriceValue(1);
            setInputPriceDiscountValue(0);

            setImgPath(''); // указываем состоянию пути для главной картинки товара пустую строку,чтобы когда пользователь(админ) выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то картинка не показывалась уже,чтобы при повторном заходе в аккаунт сразу без обновления страницы не показывалась эта картинка,которую выбрал админ до этого

            setDescImages([]); // изменяем состяние descImages на пустой массив,чтобы не показывались картинки описания после выхода из аккаунта и сразу же захода обратно без обновления страницы

            setInputFileMainImage(null);  // изменяем состояние для инпута файла главной картинки для нового товара,указываем ему значение как null,чтобы когда админ выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то чтобы при повторном заходе в аккаунт сразу без обновления страницы админ мог выбрать опять картинку

            // если inputMainImage.current true(то есть inputMainImage.current есть),делаем эту проверку,так как выдает ошибку,что inputMainImage.current может быть null
            if (inputMainImage.current) {

                inputMainImage.current.value = ''; // изменяем текущее значение у inputMainImage.current(инпута файла для главной картинки для товара) на пустую строку,то есть очищаем этот инпут для файлов,чтобы потом при выходе из аккаунта очищать значение этого инпута,чтобы когда админ выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то чтобы при повторном заходе в аккаунт сразу без обновления страницы админ мог выбрать опять картинку

            }

            // если inputDescImages.current true(то есть inputDescImages.current есть),делаем эту проверку,так как выдает ошибку,что inputDescImages.current может быть null
            if (inputDescImages.current) {

                inputDescImages.current.value = ''; // изменяем текущее значение у inputDescImages.current(инпута файла для картинок описания для товара) на пустую строку,то есть очищаем этот инпут для файлов,чтобы потом при выходе из аккаунта очищать значение этого инпута,чтобы когда админ выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то чтобы при повторном заходе в аккаунт сразу без обновления страницы админ мог выбрать опять картинку

            }

            setErrorNewProductForm(''); // убираем ошибку формы создания нового товара(чтобы если до этого пользователь(админ) выбрал неправильный файл и получил ошибку,то при выходе из аккаунта и сразу заходе обратно без обновления страницы эта ошибка убиралась)

            setErrorNewProductFormForImg(''); // убираем ошибку(это состояние конкретно для ошибки,связанной с картинкой) формы создания нового товара(чтобы если до этого пользователь(админ) выбрал неправильный файл и получил ошибку,то при выходе из аккаунта и сразу заходе обратно без обновления страницы эта ошибка убиралась)

        } catch (e: any) {

            console.log(e.response?.data?.message); // если была ошибка,то выводим ее в логи,берем ее из ответа от сервера из поля message из поля data у response у e

        }

    }

    // функция для формы изменения имени и почты пользователя,указываем тип событию e как тип FormEvent и в generic указываем,что это HTMLFormElement(html элемент формы)
    const onSubmitAccSettings = async (e: FormEvent<HTMLFormElement>) => {

        e.preventDefault(); // убираем дефолтное поведение браузера при отправке формы(перезагрузка страницы),то есть убираем перезагрузку страницы в данном случае

        // если inputEmailAccSettings.trim() не равно пустой строке(то есть в inputEmailAccSettings,отфильтрованном по пробелам, есть какое-то значение) или inputNameAccSettings.trim() не равно пустой строке(то есть в inputNameAccSettings(отфильтрованное по пробелам с помощью trim()) есть какое-то значение), то делаем запрос на сервер для изменения данных пользователя,если же в поля инпутов имени или почты пользователь ничего не ввел,то не будет отправлен запрос
        if (inputEmailAccSettings.trim() !== '' || inputNameAccSettings.trim() !== '') {

            // оборачиваем в try catch для отлавливания ошибок
            try {

                let name = inputNameAccSettings.trim(); // помещаем в переменную значение инпута имени и убираем у него пробелы с помощю trim() (указываем ей именно let,чтобы можно было изменять ее значение)

                // если name true(то есть в name есть какое-то значение),то изменяем первую букву этой строки инпута имени на первую букву этой строки инпута имени только в верхнем регистре,делаем эту проверку,иначе ошибка,так как пользователь может не ввести значение в инпут имени и тогда будет ошибка при изменении первой буквы инпута имени
                if (name) {

                    name = name.replace(name[0], name[0].toUpperCase());  // заменяем первую букву этой строки инпута имени на первую букву этой строки инпута имени только в верхнем регистре,чтобы имя начиналось с большой буквы,даже если написали с маленькой

                }

                const response = await changeAccInfoInDb(user.id, name, inputEmailAccSettings); // вызываем нашу функцию запроса на сервер для изменения данных пользователя,передаем туда user.id(id пользователя) и инпуты имени(в данном случае вынесли его в переменную name,чтобы убрать из него пробелы и сделать первую букву заглавной) и инпут почты

                setUser(response.data); // изменяем сразу объект пользователя на данные,которые пришли от сервера,чтобы не надо было обновлять страницу для обновления данных


                setErrorAccSettings(''); // изменяем состояние ошибки на пустую строку,то есть убираем ошибку

                setInputEmailAccSettings(''); // изменяем состояние инпута почты на пустую строку,чтобы убирался текст в инпуте почты после успешного запроса

                setInputNameAccSettings(''); // изменяем состояние инпута имени на пустую строку,чтобы убирался текст в инпуте имени после успешного запроса


            } catch (e: any) {

                console.log(e.response?.data?.message); // выводим ошибку в логи

                return setErrorAccSettings(e.response?.data?.message); // возвращаем и показываем ошибку,используем тут return чтобы если будет ошибка,чтобы код ниже не работал дальше,то есть на этой строчке завершим функцию,чтобы не очищались поля инпутов,если есть ошибка

            }

        }

    }

    // функция для формы изменения пароля пользователя,указываем тип событию e как тип FormEvent и в generic указываем,что это HTMLFormElement(html элемент формы)
    const onSubmitChangePassForm = async (e: FormEvent<HTMLFormElement>) => {

        e.preventDefault(); // убираем дефолтное поведение браузера при отправке формы(перезагрузка страницы),то есть убираем перезагрузку страницы в данном случае

        // если инпут текущего пароля равен пустой строке,то показываем ошибку
        if (inputCurrentPassword === '') {

            setErrorChangePass('Enter current password');

        } else if (inputNewPassword.length < 3 || inputNewPassword.length > 32) {
            // если инпут нового пароля по длине(по количеству символов) меньше 3 или больше 32,то показываем ошибку
            setErrorChangePass('New password must be 3 - 32 characters');

        } else if (inputNewPassword !== inputConfirmPassword) {
            // если значение инпута нового пароля не равно значению инпута подтвержденного пароля,то показываем ошибку
            setErrorChangePass('Passwords don`t match');

        } else {

            // оборачиваем в try catch для отлавливания ошибок
            try {

                const response = await changeAccPassInDb(user.id, inputCurrentPassword, inputNewPassword); // вызываем нашу функцию запроса на сервер для изменения пароля пользователя,передаем туда user.id(id пользователя) и значения инпутов текущего пароля и нового пароля

                console.log(response.data);

                setErrorChangePass('');  // изменяем состояние ошибки в форме для изменения пароля пользователя на пустую строку,то есть убираем ошибку 

                // изменяем состояния инпутов на пустые строки(то есть убираем у них значения)
                setInputCurrentPassword('');
                setInputNewPassword('');
                setInputConfirmPassword('');

                // изменяем значения состояний для типов инпутов(чтобы менять инпутам тип на password или text при нажатии на кнопку скрытия или показа пароля) у формы для изменения пароля пользователя,чтобы после успешного запроса на сервер для изменения пароля пользователя эти состояния опять принимали дефолтное значение(то есть скрывали текст пароля изначально)
                setHideInputCurrentPass(true);
                setHideInputNewPass(true);
                setHideInputConfirmPass(true);

            } catch (e: any) {

                console.log(e.response?.data?.message); // выводим ошибку в логи

                return setErrorChangePass(e.response?.data?.message);  // возвращаем и показываем ошибку,используем тут return чтобы если будет ошибка,чтобы код ниже не работал дальше,то есть на этой строчке завершим функцию,чтобы не очищались поля инпутов,если есть ошибка

            }

        }

    }

    const onSubmitNewProductForm = async (e: FormEvent<HTMLFormElement>) => {

        e.preventDefault(); // убираем дефолтное поведение браузера при отправке формы(перезагрузка страницы),то есть убираем перезагрузку страницы в данном случае

        // если значение инпута названия продукта,из которого убрали пробелы с помощью trim() равно пустой строке,то выводим ошибку(то есть если без пробелов это значение равно пустой строке,то показываем ошибку) или если это значение инпута,отфильтрованное по пробелам(проверяем это с trim(),чтобы нельзя было ввести например 1 символ и 2 пробела и тд) по длине меньше 3 или больше 30
        if (inputProductName.trim() === '' || inputProductName.trim().length < 3 || inputProductName.trim().length > 30) {

            setErrorNewProductForm('Product name must be 3 - 30 characters'); // показываем ошибку формы

        } else if (textareaProductDesc.trim().length < 11 || textareaProductDesc.trim().length > 200) {
            // если состояние textareaProductDesc.trim().length < 11(то есть длина значения инпута описания товара,отфильтрованного по пробелам меньше 11) или textareaProductDesc.trim().length > 200,то показываем ошибку
            setErrorNewProductForm('Product description must be 11 - 200 characters'); // показываем ошибку формы

        } else if (selectBlockCategoryValue === '') {
            // если selectBlockCategoryValue равно пустой строке,то есть категория не выбрана
            setErrorNewProductForm('Select category'); // показываем ошибку формы

        } else if (selectBlockTypeValue === '') {
            // если selectBlockTypeValue равно пустой строке,то есть тип одежды не выбран
            setErrorNewProductForm('Select type'); // показываем ошибку формы

        } else if (!sizesMass.length) {
            // если sizesMass.length false,то есть длина массива sizesMass false(то есть 0),то есть размер одежды не выбран
            setErrorNewProductForm('Select size'); // показываем ошибку формы

        } else if (inputPriceValue < 0.1) {
            // если состояние цены нового товара меньше 0.1,то показываем ошибку
            setErrorNewProductForm('Product price must be more than 0.09'); // показываем ошибку формы

        } else if (inputPriceDiscountValue >= inputPriceValue) {
            // если состояние inputPriceDiscountValue >= inputPriceValue,то есть состояние инпута цены со скидкой inputPriceDiscountValue больше или равно инпуту обычной цены товара inputPriceValue,то показываем ошибку,что цена со скидкой должна быть меньше,чем обычная цена товара
            setErrorNewProductForm('Discount price must be less than usual product price'); // показываем ошибку формы

        } else if (!inputFileMainImage) {
            // если состояние файла главной картинки для товара false(или null, или другое типа пустое или false значение(undefined,0,"",NaN)),то есть его(файла) нет,то показываем ошибку,в данном случае указываем ошибку у состояния errorNewProductFormForImg,так как разделии состояния ошибок всяких инпутов формы и ошибки,связанные с картинкой для нового товара,так сделали,чтобы правильно обработать ошибки
            setErrorNewProductFormForImg('Choose main image');

        } else if (!descImages.length) {
            // если состояние descImages.length false,то есть массив descImages пустой,то показываем ошибку,в данном случае указываем ошибку у состояния errorNewProductFormForImg,так как разделии состояния ошибок всяких инпутов формы и ошибки,связанные с картинкой для нового товара,так сделали,чтобы правильно обработать ошибки
            setErrorNewProductFormForImg('Choose description images');

        } else {

            // если errorNewProductFormForImg === '', то есть состояние ошибки для картинок в форме для создания нового товара для админа равно пустой строке,то есть ошибки нет(делаем эту проверку,потому что при загрузке неправильной картинки товара на сервер мы показываем ошибку в другом useEffect,поэтому проверяем,нету ли ошибки,перед тем,как создать новый объект товара в базе данных)
            if (errorNewProductFormForImg === '') {

                // оборачиваем в try catch для обработки ошибок
                try {

                    let newPriceDiscount; // создаем переменную для цены со скидкой,указываем ей let,чтобы можно было изменять ей значение потом,делаем эту переменную,чтобы потом ее указывать в объект при создании товара

                    let descImagesProduct: string[] = []; // создаем переменную для массива названий картинок,указываем ей let,чтобы можно было изменять ей значение потом

                    let totalPriceProduct; // переменная для totaPrice для товара

                    let categoryId; // переменная для id категории для товара,так как сделали так,что у каждой категории свой id и так связали таблицы в базе данных

                    let typeId;  // переменная для id типа для товара,так как сделали так,что у каждого типа свой id и так связали таблицы в базе данных

                    let nameProduct = inputProductName.trim(); // помещаем в переменную name(указываем ей именно let,чтобы можно было изменять) значение инпута имени товара,отфильтрованное по пробелам,если его не отфильтровать здесь по пробелам,то даже при следующем изменении этой переменной nameProduct,если там указать trim(),то не будет работать,и не будет заменять первую букву на заглавную

                    nameProduct = nameProduct.replace(nameProduct[0], nameProduct[0].toUpperCase());  // заменяем первую букву этой строки инпута имени(name[0] в данном случае) на первую букву этой строки инпута имени только в верхнем регистре(name[0].toUpperCase()),чтобы имя товара начиналось с большой буквы,даже если написали с маленькой

                    console.log(nameProduct)

                    // если inputPriceDiscountValue больше 0,то есть админ указал цену со скидкой для этого товара
                    if (inputPriceDiscountValue > 0) {

                        newPriceDiscount = inputPriceDiscountValue.toFixed(2); // указываем toFixed(2),чтобы преобразовать это число до 2 чисел после запятой,так как эти инпуты обычной цены и цены со скидкой могу быть дробными,типа с несколькими цифрами после запятой

                    } else {

                        newPriceDiscount = null; // в другом случае указываем значение переменной newPriceDiscount как null

                    }

                    // проходимся по массиву descImages и на каждой итерации добавляем image.name(название текущего итерируемого объекта картинки) в массив descImagesProduct,чтобы сохранить только названия файлов картинок в массив descImagesProduct
                    descImages.forEach(image => {

                        descImagesProduct.push(image.name);

                    })

                    // если inputPriceDiscountValue > 0,то есть админ указал скидку у товара 
                    if (inputPriceDiscountValue > 0) {

                        totalPriceProduct = inputPriceDiscountValue.toFixed(2); // изменяем значение totalPriceProduct на inputPriceDiscountValue.toFixed(2)

                    } else {
                        // в другом случае,если у товара не указана скидка,то изменяем значение totalPriceProduct на inputPriceValue.toFixed(2)(обычную цену товара)
                        totalPriceProduct = inputPriceValue.toFixed(2);
                    }

                    // если selectBlockCategoryValue(значение категории,которое выбрал админ) равен 'Long Sleeves',то указываем значение переменной categoryId как 1,так как сделали так,что в нашей базе данных у категории 'Long Sleeves' id 1,проверки ниже по такому же принципу
                    if (selectBlockCategoryValue === 'Long Sleeves') {

                        categoryId = 1;

                    } else if (selectBlockCategoryValue === 'Joggers') {

                        categoryId = 2;

                    } else if (selectBlockCategoryValue === 'T-Shirts') {

                        categoryId = 3;

                    } else if (selectBlockCategoryValue === 'Shorts') {

                        categoryId = 4;

                    }

                    // если selectBlockTypeValue(значение типа одежды,которое выбрал админ) равно 'Men',то указываем значение переменной typeId как 1,так как сделали так,что в нашей базе данных у типа 'Men' id 1,проверки ниже по такому же принципу
                    if (selectBlockTypeValue === 'Men') {

                        typeId = 1;

                    } else if (selectBlockTypeValue === 'Women') {

                        typeId = 2;

                    }

                    // делаем запрос на сервер и добавляем данные на сервер,указываем тип данных,которые нужно добавить на сервер(в данном случае IProduct),но здесь не обязательно указывать тип,используем тут наш инстанс axios ($api),чтобы правильно обрабатывался этот запрос для проверки на access токен с помощью нашего authMiddleware на нашем сервере
                    const response = await $api.post<IProduct>('/addNewProductCatalog', { name: nameProduct, descText: textareaProductDesc, categoryId: categoryId, typeId: typeId, sizes: sizesMass, price: inputPriceValue.toFixed(2), priceDiscount: newPriceDiscount, amount: 1, rating: 0, totalPrice: totalPriceProduct, mainImage: inputFileMainImage.name, descImages: descImagesProduct }); // указываем здесь первым параметром url только конкретного эндпоинта(типа без полного url до бэкэнда,потом до роутера,а только потом до эндпоинта),так как в этом нашем инстансе axios($api) мы указали параметр baseUrl(то есть базовый url для каждого запроса с помощью этого нашего инстанса axios($api),когда создавали наш этот инстанс axios,в файле http.ts) уже до нашего бэкэнда и до нашего роутера,поэтому остается только добавить url до конкретного эндпоинта, поле id не указываем,чтобы оно сгенерировалось на сервере автоматически,указываем поле mainImage как поле name у состояния inputFileMainImage(inputFileMainImage.name,то есть название файла,который выбрал пользователь(админ)), в mainImage передаем название файла картинки,которую выбрал админ для нового товара(она уже будет загружена на наш node js сервер,если она будет правильного размера),также указываем поле descImages со значением как descImagesProduct(массив только названий файлов картинок описания для товара),указываем priceDiscount со значением как у newPriceDiscount,то есть вместо него будет подставлено либо значение как newPriceDiscount,либо null(то есть ничего не будет подставлено),в зависимости от условия для этой переменной newPriceDiscount выше в коде,это чтобы указать цену со скидкой для товара,если она указана,указываем toFixed(2) для inputPriceValue,чтобы преобразовать это число до 2 чисел после запятой,так как эти инпуты обычной цены и цены со скидкой могут быть дробными,типа с несколькими цифрами после запятой,указываем totalPrice как totalPriceProduct,то есть как цену со скидкой или как обычную цену в зависимости от проверок выше в коде,указываем categoryId как переменная categoryId(делали ей проверки выше в коде) и typeId как переменная typeId(делали ей проверки выше в коде),указываем name как переменная nameProduct

                    console.log(response);

                } catch (e: any) {

                    console.log(e.response?.data?.message);

                    return setErrorNewProductForm(e.response?.data?.message);  // возвращаем и показываем ошибку,используем тут return чтобы если будет ошибка,чтобы код ниже не работал дальше,то есть на этой строчке завершим функцию,чтобы не очищались поля инпутов,если есть ошибка

                }


                setErrorNewProductForm(''); // убираем основную ошибку для всяких инпутов формы для создания нового товара для админа,так как мы разделили основную ошибку формы для всяких инпутов и ошибку формы,связанную с картинками для товара у этой формы,а убираем ошибку формы,связанную с картинками для товара, при загрузке нового файла главной картинки или картинки описания для товара

                // очищаем инпуты формы создания нового товара
                setInputProductName('');
                setSelectBlockCategoryValue('');
                setSelectBlockTypeValue('');
                setTextareaProductDesc('');
                setSizesMass([]); // очищаем массив выбранных размеров для нового товара
                setInputPriceValue(1);
                setInputPriceDiscountValue(0);

                setImgPath(''); // указываем состоянию пути для главной картинки товара пустую строку,чтобы когда пользователь(админ) выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то картинка не показывалась уже,чтобы при повторном заходе в аккаунт сразу без обновления страницы не показывалась эта картинка,которую выбрал админ до этого

                setDescImages([]); // изменяем состяние descImages на пустой массив,чтобы не показывались картинки описания после выхода из аккаунта и сразу же захода обратно без обновления страницы

                setInputFileMainImage(null);  // изменяем состояние для инпута файла главной картинки для нового товара,указываем ему значение как null,чтобы когда админ выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то чтобы при повторном заходе в аккаунт сразу без обновления страницы админ мог выбрать опять картинку

                // если inputMainImage.current true(то есть inputMainImage.current есть),делаем эту проверку,так как выдает ошибку,что inputMainImage.current может быть null
                if (inputMainImage.current) {

                    inputMainImage.current.value = ''; // изменяем текущее значение у inputMainImage.current(инпута файла для главной картинки для товара) на пустую строку,то есть очищаем этот инпут для файлов,чтобы потом при выходе из аккаунта очищать значение этого инпута,чтобы когда админ выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то чтобы при повторном заходе в аккаунт сразу без обновления страницы админ мог выбрать опять картинку

                }

                // если inputDescImages.current true(то есть inputDescImages.current есть),делаем эту проверку,так как выдает ошибку,что inputDescImages.current может быть null
                if (inputDescImages.current) {

                    inputDescImages.current.value = ''; // изменяем текущее значение у inputDescImages.current(инпута файла для картинок описания для товара) на пустую строку,то есть очищаем этот инпут для файлов,чтобы потом при выходе из аккаунта очищать значение этого инпута,чтобы когда админ выбрал картинку для товара,не сохранил ее для товара,а просто вышел из аккаунта,то чтобы при повторном заходе в аккаунт сразу без обновления страницы админ мог выбрать опять картинку

                }


            }

        }

    }

    // при рендеринге этого компонета(при запуске этой страницы в данном случае),и при изменении состояний инпутов,всяких значений выбранных категорий,инпутов цены и тд у формы для админа будет отработан код в этом useEffect
    useEffect(() => {

        setErrorNewProductForm(''); // очищаем основную ошибку формы для админа,чтобы когда будут изменяться инпуты всяких значений выбранных категорий,инпутов цены и тд,то чтобы убиралась сразу ошибка формы,так как мы разделили основную ошибку формы для всяких инпутов и ошибку формы,связанную с картинками для товара у этой формы,и чтобы если будет ошибка,связанная с картинками для товара у этой формы и если одновременно будет ошибка для всяких инпутов формы,то чтобы при изменении этих всяких инпутов формы эта ошибка для инпутов формы убиралась,иначе она не убирается(даже если всякие инпуты заполнены правильно),пока есть ошибка формы,связанная с картинками для товара,так как мы так сделали для функции обработки(отправки) onSubmitNewProductForm формы админа

    }, [inputProductName, textareaProductDesc, selectBlockCategoryValue, selectBlockTypeValue, sizesMass, inputPriceValue, inputPriceDiscountValue])

    // при изменении imgPath проверяем ширину и высоту объекта картинки(на основе new Image()),которую выбрал пользователь(мы помещаем путь до картинки на нашем сервере node js в src в этот объект картинки),не используем уже здесь useRef,типа привязать его к html тегу картинки,потом показать его ширину,так как указали в css стили этой картинке,чтобы она отображалась небольшого размера,и когда бы мы проверяли ее ширину и высоту,то всегда бы показывалась ошибка,что типа она не подходит под этот размер,так как вы в стилях указали заранее меньший размер,чем нужно,поэтому создаем объект картинки на основе Image() и уже он не будет зависеть от отображаемой картинки,проверяем у него уже ширину и высоту
    useEffect(() => {

        const img = new Image(); // создаем новый объект картинки на основе обычного Image(на основе html тега картинки),он имеет те же свойства и параметры как и обычный html тег картинки

        img.src = imgPath; // указываем путь до настоящей картинки на нашем сервере этому объекту картинки,иногда лучше указать значение src атрибуту этому объекту картинки после указания события onload у этого объекта картинки,так как иногда onload может не сработать,если src загрузится быстрее(например,возможно,в браузере IE(Internet Explorer)),но в данном случае и так работает,поэтому оставили так


        // используем тут setTimeout(код в этом callback будет выполнен через время,которое указали вторым параметром в setTimeout после запятой,это время указывается в миллисекундах,в данном случае этот код будет выполнен через 0.1 секунду(через 100 миллисекунд)),в данном случае это делаем для того,чтобы успела появится новая картинка(объект картинки в данном случае),после того,как пользователь(админ) ее выбрал в ипнуте файлов,иначе не успевает появиться и показывает ширину картинки как 0 и не работает правильно
        // setTimeout(() => {

        // в данном случае используем onload у этого объекта картинки(делаем это вместо setTimeout,чтобы успела загрузиться картинка и у нее появилась ширина,высота и тд),то есть когда этот объект картинки загрузится,то будет отработан код в этой функции callback внутри этого onload
        img.onload = () => {

            // если img.width и img.height true,то есть ширина и высота этого объекта картинки true,то есть она есть,то есть эта картинка уже загрузилась(эта проверка для того,чтобы не шел запрос на удаление картинки сразу при запуске страницы,так как у этого объекта картинки не будет изначально ширины и высоты,если эту проверку не сделать,то будет идти сразу запрос на удаление картинки при запуске страницы,так как она типа не подходит по размеру)
            if (img.width && img.height) {

                // если img.width меньше 296(то есть если ширина объекта картинки меньше 296),или если высота объекта картинки(img.height) меньше 367(эти размеры смотрели в зависимости от дизайна у карточки товара и тд),то показываем ошибку
                if (img.width < 296 || img.height < 367) {

                    setErrorNewProductFormForImg('Width must be more than 295 and height must be more than 366'); // показываем ошибку для картинки для формы админа

                    setInputFileMainImage(null); // изменяем состояние для инпута файла главной картинки для нового товара,указываем ему значение как null,чтобы если админ получил ошибку,что размер картинки неправильный,то это состояние для файла картинки становилось null,иначе будет идти запрос на сервер,когда состояние файла картинки пустое,и тогда будет ошибка на сервере,что файл картинки пустой

                    // делаем удаление файла(картинки) на сервере,который неправильного размера ширины и высоты,так как если не удалять,а нужна конкретная ширина и высота картинки,то файлы будут просто скачиваться на наш node js сервер и не удаляться,поэтому отдельно делаем запрос на сервер на удаление файла
                    deleteMainImageRequest(inputFileMainImage?.name);  // передаем в нашу функцию название файла,который пользователь выбрал в инпуте файлов(мы поместили его в состояние inputFileMainImage),наша функция deleteMainImageRequest делает запрос на сервер на удаление файла картинки и возвращает ответ от сервера(в данном случае при успешном запросе ответ от сервера будет объект с полями)

                    setImgPath(''); // изменяем состояние imgPath(пути картинки) на пустую строку,чтобы картинка не показывалась,если она неправильная по размеру и была удалена с сервера(иначе картинка показывается,даже если она удалена с сервера)

                    img.src = ''; // указываем этому объекту картинки путь до картинки как пустую строку,чтобы убрать эту картинку и чтобы она удалилась(она бы и так должна была удалиться после ререндера этого компонента(этой страницы в данном случае),но лучше все равно сразу ее убрать)

                }

            }
        }

        // }, 100)

    }, [imgPath])


    // функция для выбора картинки с помощью инпута для файлов
    const inputLoadMainImageHandler = async (e: ChangeEvent<HTMLInputElement>) => {

        // e.target.files - массив файлов,которые пользователь выбрал при клике на инпут для файлов, если e.target.files true(делаем эту проверку,потому что выдает ошибку,что e.target.files может быть null) и e.target.files[0] true,то есть пользователь выбрал файл,также указываем здесь проверку на inputFileMainImage false,то есть если inputFileMainImage false,то загружаем файл картинки,делаем эту проверку,чтобы правильно удалять и добавлять файл картинки,иначе,если загрузить картинку на сервер,а потом поменять ее еще раз,при этом ее не удалив,то при повторной попытке загрузить эту же картинку будет ошибка,что такой файл уже есть,поэтому будем делать удаление картинки по кнопке возле картинки,и потом уже опять можно добавлять другую картинку
        if (e.target.files && e.target.files[0] && !inputFileMainImage) {

            setInputFileMainImage(e.target.files[0]); // помещаем в состояние файл,который выбрал пользователь,у files указываем тут [0],то есть берем первый элемент массива(по индексу 0) этих файлов инпута

            const formData = new FormData(); // создаем объект на основе FormData(нужно,чтобы передавать файлы на сервер)

            formData.append('image', e.target.files[0]);  // добавляем в этот объект formData по ключу(названию) 'image' сам файл в e.target.files[0] по индексу 0 (первым параметром тут передаем название файла,вторым сам файл)

            console.log(e.target.files[0]);

            // оборачиваем в try catch,чтобы отлавливать ошибки и делаем пока такой запрос на сервер для загрузки файла на сервер,загружаем объект formData(лучше вынести это в отдельную функцию запроса на сервер но и так можно),указываем здесь наш инстанс axios ($api в данном случае),чтобы обрабатывать правильно запросы с access токеном и refresh токеном,в данном случае делаем запрос на бэкэнд для загрузки файла и там сразу будет проверка нашего authMiddleware на нашем node js сервере для проверки на access токен
            try {

                const response = await $api.post<FormData, AxiosResponse<IUploadFileResponse>>('/uploadFile', formData); // делаем запрос на сервер для сохранения файла на сервере и как тело запроса тут передаем formData,указываем данные,которые отправляем на сервер(FormData в данном случае) и данные,которые получаем от сервера (AxiosResponse<IUploadFileResponse> в данном случае)

                console.log(response);

                setImgPath(`${process.env.REACT_APP_BACKEND_URL}/${response.data.name}`);  // помещаем в состояние imgPath путь до файла,то есть пишем путь до нашего сервера (вынесли основной url до бэкэнда в переменную окружения REACT_APP_BACKEND_URL в файле .env) и добавляем название файла,который нужно показать,который есть в папке (в данном случае checkStatic) на нашем сервере,это название пришло от сервера

                setErrorNewProductForm(''); // убираем ошибку формы создания нового товара(чтобы если до этого пользователь выбрал неправильный файл и получил ошибку,то при повторном выборе файла эта ошибка убиралась)

                setErrorNewProductFormForImg(''); // убираем ошибку(это состояние конкретно для ошибки,связанной с картинкой) формы создания нового товара(чтобы если до этого пользователь(админ) выбрал неправильный файл и получил ошибку,то при повторном выборе файла эта ошибка убиралась)

            } catch (e: any) {

                setInputFileMainImage(null);  // изменяем состояние файла на null,чтобы если ошибка,то название картинки не показывалось

                return setErrorNewProductFormForImg(e.response?.data?.message); // возвращаем и показываем ошибку,используем тут return чтобы если будет ошибка,чтобы код ниже не работал дальше,то есть на этой строчке завершим функцию,чтобы не очищались поля инпутов,если есть ошибка

            }

        }

    }

    // при изменении imgPath проверяем ширину и высоту объекта картинки(на основе new Image()),которую выбрал пользователь(мы помещаем путь до картинки на нашем сервере node js в src в этот объект картинки),не используем уже здесь useRef,типа привязать его к html тегу картинки,потом показать его ширину,так как указали в css стили этой картинке,чтобы она отображалась небольшого размера,и когда бы мы проверяли ее ширину и высоту,то всегда бы показывалась ошибка,что типа она не подходит под этот размер,так как вы в стилях указали заранее меньший размер,чем нужно,поэтому создаем объект картинки на основе Image() и уже он не будет зависеть от отображаемой картинки,проверяем у него уже ширину и высоту
    useEffect(() => {

        // если descImages.length true,то есть длина массива descImages есть,делаем эту проверку,чтобы если этот массив пустой,то не создавался объект картинки(new Image()),так как тогда выдает ошибку,что не найти url у descImages[descImages.length - 1] для src(пути) этой картинки,так как этот массив descImages пустой,а этот useEffect срабатывает при рендере этого компонента(в данном случае этой страницы),а также при изменении массива descImages
        if (descImages.length) {

            const img = new Image(); // создаем новый объект картинки на основе обычного Image(на основе html тега картинки),он имеет те же свойства и параметры как и обычный html тег картинки

            img.src = descImages[descImages.length - 1].url; // указываем путь до настоящей картинки на нашем сервере этому объекту картинки(указываем descImages[descImages.length - 1]?.url,то есть поле url у элемента массива descImages по индексу descImages.length - 1,то есть у последнего элемента этого массива),иногда лучше указать значение src атрибуту этому объекту картинки после указания события onload у этого объекта картинки,так как иногда onload может не сработать,если src загрузится быстрее(например,возможно,в браузере IE(Internet Explorer)),но в данном случае и так работает,поэтому оставили так


            // используем тут setTimeout(код в этом callback будет выполнен через время,которое указали вторым параметром в setTimeout после запятой,это время указывается в миллисекундах,в данном случае этот код будет выполнен через 0.1 секунду(через 100 миллисекунд)),в данном случае это делаем для того,чтобы успела появится новая картинка(объект картинки в данном случае),после того,как пользователь(админ) ее выбрал в ипнуте файлов,иначе не успевает появиться и показывает ширину картинки как 0 и не работает правильно
            // setTimeout(() => {

            // в данном случае используем onload у этого объекта картинки(делаем это вместо setTimeout,чтобы успела загрузиться картинка и у нее появилась ширина,высота и тд),то есть когда этот объект картинки загрузится,то будет отработан код в этой функции callback внутри этого onload
            img.onload = () => {

                // если img.width и img.height true,то есть ширина и высота этого объекта картинки true,то есть она есть,то есть эта картинка уже загрузилась(эта проверка для того,чтобы не шел запрос на удаление картинки сразу при запуске страницы,так как у этого объекта картинки не будет изначально ширины и высоты,если эту проверку не сделать,то будет идти сразу запрос на удаление картинки при запуске страницы,так как она типа не подходит по размеру),также делаем проверку на canDelete true,чтобы не циклилось удаление массива descImages,так как этот useEffect будет срабатывать при изменении массива descImages,а когда мы удаляем из него элемент,то этот массив изменяется и соответственно, опять срабатывает этот useEffect,поэтому,когда удалили элемент из descImages,изменяем состояние canDelete на false,чтобы опять он не удалялся,а в функции inputLoadDescImagesHandler изменяем это состояние на true,чтобы можно было удалять элемент из descImages 
                if (img.width && img.height && canDelete) {

                    // если img.width меньше 296(то есть если ширина объекта картинки меньше 296),или если высота объекта картинки(img.height) меньше 367(эти размеры смотрели в зависимости от дизайна у карточки товара и тд),то показываем ошибку
                    if (img.width < 296 || img.height < 367) {

                        setErrorNewProductFormForImg('Width must be more than 295 and height must be more than 366'); // показываем ошибку для картинки для формы админа

                        setDescImages((prev) => [...prev.slice(0, descImages.length - 1)]); // можно развернуть отфильтрованный массив в новый,но можно и не разворачивать а просто сразу прописать prev.slice(0,-1) и это будет также работать,так как slice() и так возвращает новый массив,поэтому это состояние будет также изменено на новый массив без разворачивания(...) в другой,первым параметром указываем с какого элемента по индексу начинать извлекать,а вторым параметром указываем по какой элемент по индексу не включительно начать извлекать(значение -1 для второго параметра будет значить,что извлечение будет до предпоследнего элемента,то есть последний элемент массива не будет извлечен),slice возвращает новый массив,содержащий извлеченные элементы,то есть в данном случае указываем,что вырезаем элементы из массива начиная с индекса 0 и до индекса descImages.length - 1(то есть длина массива descImages - 1,чтобы указать индекс последнего элемента массива),то есть до индекса последнего элемента не включительно,то есть последний элемент массива не будет вырезан,таким образом удаляем последний добавленный элемент этого массива descImages

                        console.log(descImages)

                        setCanDelete(false); // изменяем состояние canDelete на false,чтобы опять не удалялся элемент из массива descImages, и не циклилось это удаление

                        // делаем удаление файла(картинки) на сервере,который не правильного размера ширины и высоты,так как если не удалять,а нужна конкретная ширина и высота картинки,то файлы будут просто скачиваться на наш node js сервер и не удаляться,поэтому отдельно делаем запрос на сервер на удаление файла
                        deleteMainImageRequest(descImages[descImages.length - 1].name); // передаем в нашу функцию название файла,который пользователь выбрал в инпуте файлов(указываем descImages[descImages.length - 1]?.name,то есть поле name у элемента массива descImages по индексу descImages.length - 1,то есть у последнего элемента этого массива),наша функция deleteMainImageRequest делает запрос на сервер на удаление файла картинки и возвращает ответ от сервера(в данном случае при успешном запросе ответ от сервера будет объект с полями),используем здесь такой же запрос на удаление картинки,как и для главной картинки mainImage,так как тут логика одинаковая

                        img.src = ''; // указываем этому объекту картинки путь до картинки как пустую строку,чтобы убрать эту картинку и чтобы она удалилась(она бы и так должна была удалиться после ререндера этого компонента(этой страницы в данном случае),но лучше все равно сразу ее убрать)

                    }

                }
            }

            // }, 100)

        }

    }, [descImages])

    // функция для выбора картинок описаний товара с помощью инпута для файлов
    const inputLoadDescImagesHandler = async (e: ChangeEvent<HTMLInputElement>) => {

        // e.target.files - массив файлов,которые пользователь выбрал при клике на инпут для файлов, если e.target.files true(делаем эту проверку,потому что выдает ошибку,что e.target.files может быть null) и e.target.files[0] true,то есть пользователь выбрал файл и также делаем проверку на descImage.length < 3,то есть длина массива descImages меньше 3,то загружаем файл картинки на сервер,указываем здесь проверку меншье 3(а предполагаем,что максимум можно 3 картинки),так как здесь еще не успевает переобновиться состояние descImages и оно на 1 опережает,не делаем здесь проверку на descImages.length,чтобы показать ошибку,так как будем просто выводить текст с текущим и максимально допустимым количеством картинок,иначе если показывать тут ошибку,то она будет видна и нельзя будет создать новый товар,так как будет висеть эта ошибка,даже если количество картинок правильное
        if (e.target.files && e.target.files[0] && descImages.length < 3) {

            const formData = new FormData(); // создаем объект на основе FormData(нужно,чтобы передавать файлы на сервер)

            formData.append('image', e.target.files[0]);  // добавляем в этот объект formData по ключу(названию) 'image' сам файл в e.target.files[0] по индексу 0 (первым параметром тут передаем название файла,вторым сам файл)

            console.log(e.target.files[0]);

            // оборачиваем в try catch,чтобы отлавливать ошибки и делаем пока такой запрос на сервер для загрузки файла на сервер,загружаем объект formData(лучше вынести это в отдельную функцию запроса на сервер но и так можно),указываем здесь наш инстанс axios ($api в данном случае),чтобы обрабатывать правильно запросы с access токеном и refresh токеном,в данном случае делаем запрос на бэкэнд для загрузки файла и там сразу будет проверка нашего authMiddleware на нашем node js сервере для проверки на access токен
            try {

                const response = await $api.post<FormData, AxiosResponse<IUploadFileResponse>>('/uploadFile', formData); // делаем запрос на сервер для сохранения файла на сервере и как тело запроса тут передаем formData,указываем данные,которые отправляем на сервер(FormData в данном случае) и данные,которые получаем от сервера (AxiosResponse<IUploadFileResponse> в данном случае)

                console.log(response);

                // создаем переменную объекта картинки описания
                const objImage = {
                    name: e.target.files[0].name, // указываем поле name со значением e.target.files[0].name,то есть названием текущего файла,который пользователь выбрал сейчас у инпута файлов

                    url: `${process.env.REACT_APP_BACKEND_URL}/${response.data.name}` // указываем поле url,в котором будет путь до картинки на нашем сервере,то есть пишем путь до нашего сервера (в данном случае вынесли основной url до сервера в переменную REACT_APP_BACKEND_URL в env файле) и добавляем название файла(он пришел от сервера в response.data.name),который нужно показать,который есть в папке (в данном случае checkStatic) на нашем сервере,это название пришло от сервера
                }

                setDescImages((prev) => [...prev, objImage]);  // изменяем массив descImages,разворачиваем в новый массив текущее состояние этого массива(...prev) и добавляем новый объект картинки описания(objImage)

                setCanDelete(true); // изменяем состояние canDelete на true,чтобы можно было удалять элемент из descImages

                setErrorNewProductForm(''); // убираем ошибку формы создания нового товара(чтобы если до этого пользователь выбрал неправильный файл и получил ошибку,то при повторном выборе файла эта ошибка убиралась)

                setErrorNewProductFormForImg(''); // убираем ошибку(это состояние конкретно для ошибки,связанной с картинкой) формы создания нового товара(чтобы если до этого пользователь(админ) выбрал неправильный файл и получил ошибку,то при повторном выборе файла эта ошибка убиралась)

            } catch (e: any) {

                return setErrorNewProductFormForImg(e.response?.data?.message); // возвращаем и показываем ошибку,используем тут return чтобы если будет ошибка,чтобы код ниже не работал дальше,то есть на этой строчке завершим функцию,чтобы не очищались поля инпутов,если есть ошибка

            }

        }

    }


    // функция для изменения значения инпута цены товара,указываем параметру e(event) тип как ChangeEvent<HTMLInputElement>
    const changeInputPriceValue = (e: ChangeEvent<HTMLInputElement>) => {

        // если текущее значение инпута < или равно 0,то ставим значение инпуту 0,чтобы меньше 0 не уменьшалось
        if (+e.target.value <= 0) {

            setInputPriceValue(0);

        } else {

            setInputPriceValue(Number((+e.target.value).toFixed(2))); // изменяем состояние инпута цены на (+e.target.value).toFixed(2) (текущее значение инпута,округленное до 2 чисел после запятой,указываем это toFixed(2),чтобы больше 2 цифр после запятой не показывалось в инпуте,иначе иногда оно может так показывать,если изменять это значение на - 1 и тд),указываем + перед e.target.value,чтобы перевести текущее значение инпута из строки в число,оборачиваем это все в Number(),чтобы преобразовать это все в число,Number() - преобразовывает переданный в нее аргумент в число,в данном случае преобразовываем строку в число,если преобразование будет невозможно,то будет возвращен NaN(not a number),иначе выдает ошибку,что нельзя назначить строку для состояния inputPriceValue

        }

    }

    const handlerMinusPriceProductBtn = () => {

        // если значение инпута цены товара больше 1,то изменяем это значение на - 1,в другом случае указываем ему значение 1,чтобы после нуля не отнимало - 1
        if (inputPriceValue > 1) {

            setInputPriceValue((prev) => +(prev - 1).toFixed(2)); // изменяем состояние инпута цены на (prev - 1).toFixed(2) (текущее значение инпута - 1,округленное до 2 чисел после запятой,указываем это toFixed(2),чтобы больше 2 цифр после запятой не показывалось в инпуте,иначе иногда оно может так показывать,если изменять это значение на - 1 и тд),указываем + перед e.target.value,чтобы перевести текущее значение инпута из строки в число,также указываем + перед этим всем выражением,чтобы преобразовать это в число,в данном случае преобразовываем строку в число,если преобразование будет невозможно,то будет возвращен NaN(not a number),иначе выдает ошибку,что нельзя назначить строку для состояния inputPriceValue

        } else {

            setInputPriceValue(0);

        }

    }

    const handlerPlusPriceProductBtn = () => {

        // изменяем текущее значение инпута цены товара на + 1
        setInputPriceValue((prev) => +(prev + 1).toFixed(2)); // изменяем состояние инпута цены на (prev + 1).toFixed(2) (текущее значение инпута + 1,округленное до 2 чисел после запятой,указываем это toFixed(2),чтобы больше 2 цифр после запятой не показывалось в инпуте,иначе иногда оно может так показывать,если изменять это значение на - 1 и тд),указываем + перед e.target.value,чтобы перевести текущее значение инпута из строки в число,также указываем + перед этим всем выражением,чтобы преобразовать это в число,в данном случае преобразовываем строку в число,если преобразование будет невозможно,то будет возвращен NaN(not a number),иначе выдает ошибку,что нельзя назначить строку для состояния inputPriceValue

    }

    // функция для изменения значения инпута цены товара,указываем параметру e(event) тип как ChangeEvent<HTMLInputElement>
    const changeInputPriceDiscountValue = (e: ChangeEvent<HTMLInputElement>) => {

        // если текущее значение инпута < или равно 0,то ставим значение инпуту 0,чтобы меньше 0 не уменьшалось
        if (+e.target.value <= 0) {

            setInputPriceDiscountValue(0);

        } else {

            setInputPriceDiscountValue(Number((+e.target.value).toFixed(2))); // изменяем состояние инпута цены на (+e.target.value).toFixed(2) (текущее значение инпута,округленное до 2 чисел после запятой,указываем это toFixed(2),чтобы больше 2 цифр после запятой не показывалось в инпуте,иначе иногда оно может так показывать,если изменять это значение на - 1 и тд),указываем + перед e.target.value,чтобы перевести текущее значение инпута из строки в число,оборачиваем это все в Number(),чтобы преобразовать это все в число,Number() - преобразовывает переданный в нее аргумент в число,в данном случае преобразовываем строку в число,если преобразование будет невозможно,то будет возвращен NaN(not a number),иначе выдает ошибку,что нельзя назначить строку для состояния inputPriceValue

        }

    }

    const handlerMinusPriceDiscountProductBtn = () => {

        // если значение инпута цены товара больше 1,то изменяем это значение на - 1,в другом случае указываем ему значение 0,чтобы после нуля не отнимало - 1
        if (inputPriceDiscountValue > 1) {

            setInputPriceDiscountValue((prev) => +(prev - 1).toFixed(2)); // изменяем состояние инпута цены на (prev - 1).toFixed(2) (текущее значение инпута - 1,округленное до 2 чисел после запятой,указываем это toFixed(2),чтобы больше 2 цифр после запятой не показывалось в инпуте,иначе иногда оно может так показывать,если изменять это значение на - 1 и тд),указываем + перед e.target.value,чтобы перевести текущее значение инпута из строки в число,также указываем + перед этим всем выражением,чтобы преобразовать это в число,в данном случае преобразовываем строку в число,если преобразование будет невозможно,то будет возвращен NaN(not a number),иначе выдает ошибку,что нельзя назначить строку для состояния inputPriceValue

        } else {

            setInputPriceDiscountValue(0);

        }

    }

    const handlerPlusPriceDiscountProductBtn = () => {

        // изменяем текущее значение инпута цены товара на + 1
        setInputPriceDiscountValue((prev) => +(prev + 1).toFixed(2)); // изменяем состояние инпута цены на (prev + 1).toFixed(2) (текущее значение инпута + 1,округленное до 2 чисел после запятой,указываем это toFixed(2),чтобы больше 2 цифр после запятой не показывалось в инпуте,иначе иногда оно может так показывать,если изменять это значение на - 1 и тд),указываем + перед e.target.value,чтобы перевести текущее значение инпута из строки в число,также указываем + перед этим всем выражением,чтобы преобразовать это в число,в данном случае преобразовываем строку в число,если преобразование будет невозможно,то будет возвращен NaN(not a number),иначе выдает ошибку,что нельзя назначить строку для состояния inputPriceValue

    }

    // если состояние загрузки true,то есть идет загрузка запроса на сервер для проверки,авторизован ли пользователь,то показываем лоадер(загрузку),если не отслеживать загрузку при функции checkAuth(для проверки на refresh токен при запуске страницы),то будет не правильно работать(только через некоторое время,когда запрос на /refresh будет отработан,поэтому нужно отслеживать загрузку и ее возвращать как разметку страницы,пока грузится запрос на /refresh)
    if (isLoading) {

        // возвращаем тег main с классом main,так как указали этому классу стили,чтобы был прижат header и footer
        return (
            <main className="main">
                <div className="container">
                    <div className="innerForLoader">
                        <div className="loader"></div>
                    </div>
                </div>
            </main>
        )

    }

    // если isAuth false,то есть пользователь не авторизован(когда возвращается ошибка от сервера от эндпоинта /refresh в функции checkAuth,то isAuth становится типа false,и тогда пользователя типа выкидывает из аккаунта,то есть в данном случае возвращаем компонент формы регистрации и авторизации),то возвращаем компонент формы,вместо страницы пользователя,когда пользотватель логинится и вводит правильно данные,то эта проверка на isAuth тоже работает правильно и если данные при логине были введены верно,то сразу показывается страница пользователя(даже без использования отдельного useEffect)
    if (!isAuth) {

        return (
            <main className="main">

                <SectionUnderTop subtext="My Account" /> {/* указываем пропс(параметр) subtext(в данном случае со значением My Account,чтобы отобразить в этой секции текст My Account,так как это для страницы аккаунта пользователя),чтобы использовать этот компонент на разных страницах,а отличаться он будет только этим параметром subtext */}

                <UserPageFormComponent />

            </main>
        )

    }


    return (
        <main className="main">

            <SectionUnderTop subtext="My Account" /> {/* указываем пропс(параметр) subtext(в данном случае со значением My Account,чтобы отобразить в этой секции текст My Account,так как это для страницы аккаунта пользователя),чтобы использовать этот компонент на разных страницах,а отличаться он будет только этим параметром subtext */}

            <section className="sectionUserPage">
                <div className="container">
                    <div className="sectionUserPage__inner">
                        <div className="sectionUserPage__leftBar">

                            <div className="sectionCategories__topBlock sectionUserPage__leftBar-topBlock">
                                <div className="sectionCategories__topBlock-leftBorderBlock"></div>
                                <h1 className="sectionCategories__topBlock-title sectionUserPage__leftBar-title">Hello {user.userName}</h1>
                            </div>

                            <p className="sectionUserPage__leftBar-subtitle">Welcome to your Account</p>

                            <ul className="sectionUserPage__leftBar-menu">
                                <li className="sectionUserPage__menu-item">
                                    <button className={tab === 'Dashboard' ? "sectionUserPage__menu-btn sectionUserPage__menu-btn--active" : "sectionUserPage__menu-btn"} onClick={() => setTab('Dashboard')}>
                                        <img src="/images/sectionUserPage/dashboard 2.png" alt="" className="sectionUserPage__menu-btnImg" />
                                        <p className="sectionUserPage__menu-btnText">Dashboard</p>
                                    </button>
                                </li>

                                {/* если user.role === 'USER'(то есть если роль пользователя равна "USER"),то показываем таб с настройками профиля пользователя */}
                                {user.role === 'USER' &&

                                    <li className="sectionUserPage__menu-item">
                                        <button className={tab === 'Account Settings' ? "sectionUserPage__menu-btn sectionUserPage__menu-btn--active" : "sectionUserPage__menu-btn"} onClick={() => setTab('Account Settings')}>
                                            <img src="/images/sectionUserPage/dashboard 2 (1).png" alt="" className="sectionUserPage__menu-btnImg" />
                                            <p className="sectionUserPage__menu-btnText">Account Settings</p>
                                        </button>
                                    </li>

                                }

                                {/* если user.role === 'ADMIN'(то есть если роль пользователя равна "ADMIN"),то показываем таб с панелью для админа */}
                                {user.role === 'ADMIN' &&

                                    <li className="sectionUserPage__menu-item">
                                        <button className={tab === 'Admin Panel' ? "sectionUserPage__menu-btn sectionUserPage__menu-btn--active" : "sectionUserPage__menu-btn"} onClick={() => setTab('Admin Panel')}>
                                            <img src="/images/sectionUserPage/dashboard 2 (1).png" alt="" className="sectionUserPage__menu-btnImg" />
                                            <p className="sectionUserPage__menu-btnText">Admin Panel</p>
                                        </button>
                                    </li>

                                }



                            </ul>

                            <div className="sectionUserPage__menu-item">
                                <button className="sectionUserPage__menu-btn" onClick={logout}>
                                    <img src="/images/sectionUserPage/dashboard 2 (2).png" alt="" className="sectionUserPage__menu-btnImg" />
                                    <p className="sectionUserPage__menu-btnText">Logout</p>
                                </button>
                            </div>

                        </div>
                        <div className="sectionUserPage__mainBlock">

                            {tab === 'Dashboard' &&
                                <div className="sectionUserPage__mainBlock-inner">

                                    <div className="sectionUserPage__mainBlock-dashboard">
                                        <img src="/images/sectionUserPage/Ellipse 5.png" alt="" className="sectionUserPage__dashboard-img" />
                                        <h3 className="sectionUserPage__dashboard-title">{user.userName}</h3>
                                        <p className="sectionUserPage__dashboard-email">{user.email}</p>

                                        {/* если user.role === 'USER'(то есть если роль пользователя равна "USER"),то показываем кнопку, по которой можно перейти в настройки аккаунта пользователя*/}
                                        {user.role === 'USER' &&
                                            <button className="sectionUserPage__dashboard-btn" onClick={() => setTab('Account Settings')}>Edit Profile</button>
                                        }

                                        {/* если user.role === 'ADMIN'(то есть если роль пользователя равна "ADMIN"),то показываем кнопку, по которой можно перейти в панель для админа */}
                                        {user.role === 'ADMIN' &&
                                            <button className="sectionUserPage__dashboard-btn" onClick={() => setTab('Admin Panel')}>Go to Admin Panel</button>
                                        }


                                    </div>

                                </div>
                            }

                            {/* если user.role === 'USER'(то есть если роль пользователя равна "USER") и tab === 'Account Settings',то показываем таб с настройками профиля пользователя */}
                            {user.role === 'USER' && tab === 'Account Settings' &&
                                <div className="sectionUserPage__mainBlock-inner">

                                    <form className="sectionUserPage__mainBlock-formInfo" onSubmit={onSubmitAccSettings}>
                                        <h2 className="sectionUserPage__formInfo-title">Account Settings</h2>
                                        <div className="sectionUserPage__formInfo-mainBlock">
                                            <div className="sectionUserPage__formInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">Name</p>
                                                <input type="text" className="signInForm__inputEmailBlock-input sectionUserPage__formInfo-itemInput" placeholder={`${user.userName}`} value={inputNameAccSettings} onChange={(e) => setInputNameAccSettings(e.target.value)} />
                                            </div>
                                            <div className="sectionUserPage__formInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">Email</p>
                                                <input type="text" className="signInForm__inputEmailBlock-input sectionUserPage__formInfo-itemInput" placeholder={`${user.email}`} value={inputEmailAccSettings} onChange={(e) => setInputEmailAccSettings(e.target.value)} />
                                            </div>

                                            {/* если errorAccSettings true(то есть в состоянии errorAccSettings что-то есть),то показываем текст ошибки */}
                                            {errorAccSettings && <p className="formErrorText">{errorAccSettings}</p>}

                                            {/* указываем этой кнопке тип submit,чтобы при нажатии на нее сработало событие onSubmit у этой формы */}
                                            <button className="signInForm__btn sectionUserPage__formInfo-btn" type="submit">Save Changes</button>

                                        </div>
                                    </form>

                                    <form className="sectionUserPage__mainBlock-formInfo sectionUserPage__mainBlock-formChangePass" onSubmit={onSubmitChangePassForm}>
                                        <h2 className="sectionUserPage__formInfo-title">Change Password</h2>
                                        <div className="sectionUserPage__formInfo-mainBlock">
                                            <div className="sectionUserPage__formInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">Current Password</p>

                                                {/* если состояние hideInputCurrentPass true,то делаем этому инпуту тип как password,в другом случае делаем тип как text,и потом по кнопке показать или скрыть пароль в инпуте для пароля таким образом его скрываем или показываем */}
                                                <input type={hideInputCurrentPass ? "password" : "text"} className="signInForm__inputEmailBlock-input sectionUserPage__formInfo-itemInput" placeholder="Current Password" value={inputCurrentPassword} onChange={(e) => setInputCurrentPassword(e.target.value)} />
                                                <button className="signInForm__inputEmailBlock-hideBtn formChangePass__item-hideBtn" type="button" onClick={() => setHideInputCurrentPass((prev) => !prev)}>
                                                    <img src="/images/sectionUserPage/Icon.png" alt="" className="signInForm__inputEmailBlock-imgHide" />
                                                </button>
                                            </div>
                                            <div className="sectionUserPage__formInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">New Password</p>
                                                <input type={hideInputNewPass ? "password" : "text"} className="signInForm__inputEmailBlock-input sectionUserPage__formInfo-itemInput" placeholder='New Password' value={inputNewPassword} onChange={(e) => setInputNewPassword(e.target.value)} />
                                                <button className="signInForm__inputEmailBlock-hideBtn formChangePass__item-hideBtn" type="button" onClick={() => setHideInputNewPass((prev) => !prev)}>
                                                    <img src="/images/sectionUserPage/Icon.png" alt="" className="signInForm__inputEmailBlock-imgHide" />
                                                </button>
                                            </div>
                                            <div className="sectionUserPage__formInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">Confirm Password</p>
                                                <input type={hideInputConfirmPass ? "password" : "text"} className="signInForm__inputEmailBlock-input sectionUserPage__formInfo-itemInput" placeholder='Confirm Password' value={inputConfirmPassword} onChange={(e) => setInputConfirmPassword(e.target.value)} />
                                                <button className="signInForm__inputEmailBlock-hideBtn formChangePass__item-hideBtn" type="button" onClick={() => setHideInputConfirmPass((prev) => !prev)}>
                                                    <img src="/images/sectionUserPage/Icon.png" alt="" className="signInForm__inputEmailBlock-imgHide" />
                                                </button>
                                            </div>

                                            {/* если errorChangePass true(то есть в состоянии errorChangePass что-то есть),то показываем текст ошибки */}
                                            {errorChangePass && <p className="formErrorText">{errorChangePass}</p>}

                                            {/* указываем этой кнопке тип submit,чтобы при нажатии на нее сработало событие onSubmit у этой формы */}
                                            <button className="signInForm__btn sectionUserPage__formInfo-btn" type="submit">Change Password</button>

                                        </div>
                                    </form>

                                </div>
                            }

                            {/* если user.role === 'ADMIN'(то есть если роль пользователя равна "ADMIN") и tab === 'Admin Panel',то показываем таб с настройками профиля пользователя */}
                            {user.role === 'ADMIN' && tab === 'Admin Panel' &&
                                <div className="sectionUserPage__mainBlock-inner">

                                    <form className="sectionUserPage__mainBlock-formInfo sectionUserPage__mainBlock-formChangePass" onSubmit={onSubmitNewProductForm}>
                                        <h2 className="sectionUserPage__formInfo-title">New Product</h2>
                                        <div className="sectionUserPage__formInfo-mainBlock">
                                            <div className="sectionUserPage__formInfo-item sectionUserPage__adminFormInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">Name</p>
                                                <input type="text" className="signInForm__inputEmailBlock-input sectionUserPage__formInfo-itemInput" placeholder="Name" value={inputProductName} onChange={(e) => setInputProductName(e.target.value)} />
                                            </div>
                                            <div className="sectionUserPage__formInfo-item sectionUserPage__adminFormInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">Product Description</p>
                                                <textarea className="form__mainBlock-textArea adminForm__textarea" placeholder="Enter product description" value={textareaProductDesc} onChange={(e) => setTextareaProductDesc(e.target.value)}></textarea>
                                            </div>
                                            <div className="sectionUserPage__formInfo-item sectionUserPage__adminFormInfo-itemCategory sectionUserPage__adminFormInfo-item">
                                                <div className="searchBlock__sortBlock">
                                                    <p className="sortBlock__text">Category:</p>
                                                    <div className="sortBlock__inner">
                                                        <div className="sortBlock__topBlock" onClick={() => setActiveSelectBlockCategory((prev) => !prev)}>
                                                            {/* если selectBlockCategoryValue true,то есть если в selectBlockCategoryValue есть какое-то значение,то указываем такие классы,в другом случае другие,в данном случае делаем это для анимации появления текста */}
                                                            <p className={selectBlockCategoryValue ? "sortBlock__topBlock-text sortBlock__topBlock-text--active" : "sortBlock__topBlock-text"}>{selectBlockCategoryValue}</p>
                                                            <img src="/images/sectionCatalog/Icon.png" alt="" className={activeSelectBlockCategory ? "sortBlock__topBlock-img sortBlock__topBlock-img--active" : "sortBlock__topBlock-img"} />
                                                        </div>
                                                        <div className={activeSelectBlockCategory ? "sortBlock__optionsBlock sortBlock__optionsBlock--active sortBlockAdminPanel__optionsBlock--active" : "sortBlock__optionsBlock"}>

                                                            {/* в onclick передаем функцию callback внутри которого передаем нашу функцию selectBlockCategoryItemHandler и в нее передаем параметром название категории,которая есть у этого item(то есть таким образом указываем выбранную категорию и закрываем этот селект блок,а при этом используем одну функцию selectBlockCategoryItemHandler,передавая в параметр разные значения) */}
                                                            <div className="sortBlock__optionsBlock-item" onClick={() => selectBlockCategoryItemHandler('Long Sleeves')}>
                                                                <p className="optionsBlock__item-text">Long Sleeves</p>
                                                            </div>
                                                            <div className="sortBlock__optionsBlock-item" onClick={() => selectBlockCategoryItemHandler('Joggers')}>
                                                                <p className="optionsBlock__item-text">Joggers</p>
                                                            </div>
                                                            <div className="sortBlock__optionsBlock-item" onClick={() => selectBlockCategoryItemHandler('T-Shirts')}>
                                                                <p className="optionsBlock__item-text">T-Shirts</p>
                                                            </div>
                                                            <div className="sortBlock__optionsBlock-item" onClick={() => selectBlockCategoryItemHandler('Shorts')}>
                                                                <p className="optionsBlock__item-text">Shorts</p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>

                                                <div className="searchBlock__sortBlock">
                                                    <p className="sortBlock__text">Type:</p>
                                                    <div className="sortBlock__inner">
                                                        <div className="sortBlock__topBlock" onClick={() => setActiveSelectBlockType((prev) => !prev)}>
                                                            {/* если selectBlockCategoryValue true,то есть если в selectBlockCategoryValue есть какое-то значение,то указываем такие классы,в другом случае другие,в данном случае делаем это для анимации появления текста */}
                                                            <p className={selectBlockTypeValue ? "sortBlock__topBlock-text sortBlock__topBlock-text--active" : "sortBlock__topBlock-text"}>{selectBlockTypeValue}</p>
                                                            <img src="/images/sectionCatalog/Icon.png" alt="" className={activeSelectBlockType ? "sortBlock__topBlock-img sortBlock__topBlock-img--active" : "sortBlock__topBlock-img"} />
                                                        </div>
                                                        <div className={activeSelectBlockType ? "sortBlock__optionsBlock sortBlock__optionsBlock--active sortBlockAdminPanel__optionsBlock--active" : "sortBlock__optionsBlock"}>

                                                            {/* в onclick передаем функцию callback внутри которого передаем нашу функцию selectBlockCategoryItemHandler и в нее передаем параметром название категории,которая есть у этого item(то есть таким образом указываем выбранную категорию и закрываем этот селект блок,а при этом используем одну функцию selectBlockCategoryItemHandler,передавая в параметр разные значения) */}
                                                            <div className="sortBlock__optionsBlock-item" onClick={() => selectBlockTypeItemHandler('Men')}>
                                                                <p className="optionsBlock__item-text">Men</p>
                                                            </div>
                                                            <div className="sortBlock__optionsBlock-item" onClick={() => selectBlockTypeItemHandler('Women')}>
                                                                <p className="optionsBlock__item-text">Women</p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="sectionUserPage__formInfo-item sectionUserPage__adminFormInfo-item">
                                                <p className="sectionUserPage__formInfo-itemText">Size</p>
                                                <div className="filterItem__labels-sizes adminForm__filterItem-sizes">
                                                    {/* в onClick этой кнопке указываем функцию callback внутри которой указываем нашу функцию addSizes,в которую передаем просто значение размера,которое нужно добавить или убрать из массива выбранных размеров для товара,и для класса делаем проверку,sizesMass.some(item => item === 'S') true,то есть в массиве sizesMass есть элемент со значением 'S' (в данном случае),то показываем активный класс кнопке,в другом случае обычный,указываем type этой кнопке как button,чтобы при нажатии на эти кнопки не отправлялась форма,то есть не срабатывало событие onSubmit у этой формы */}
                                                    <button type="button" className={sizesMass.some(item => item === 'S') ? "filterBar__filterItem-sizeBtn filterBar__filterItem-sizeBtn--active" : "filterBar__filterItem-sizeBtn"} onClick={() => addSizes('S')}>S</button>

                                                    <button type="button" className={sizesMass.some(item => item === 'M') ? "filterBar__filterItem-sizeBtn filterBar__filterItem-sizeBtn--active" : "filterBar__filterItem-sizeBtn"} onClick={() => addSizes('M')}>M</button>

                                                    <button type="button" className={sizesMass.some(item => item === 'L') ? "filterBar__filterItem-sizeBtn filterBar__filterItem-sizeBtn--active" : "filterBar__filterItem-sizeBtn"} onClick={() => addSizes('L')}>L</button>

                                                    <button type="button" className={sizesMass.some(item => item === 'XL') ? "filterBar__filterItem-sizeBtn filterBar__filterItem-sizeBtn--active" : "filterBar__filterItem-sizeBtn"} onClick={() => addSizes('XL')}>XL</button>
                                                </div>
                                            </div>
                                            <div className="sectionUserPage__formInfo-item sectionUserPage__adminForm-itemPrice sectionUserPage__adminFormInfo-item">
                                                <div className="adminForm__itemPrice-inputBlock">
                                                    <p className="sectionUserPage__formInfo-itemText">Price</p>
                                                    <div className="sectionProductItemPage__cartBlock-inputBlock">
                                                        {/* указываем этой кнопке тип button(type="button"),чтобы при нажатии на нее не отправлялась эта форма(для создания нового товара),указываем тип submit только одной кнопке формы,по которой она должна отправляться(то есть при нажатии на которую должен идти запрос на сервер для создания нового товара),всем остальным кнопкам формы указываем тип button */}
                                                        <button type="button" className="cartBlock__inputBlock-btn cartBlock__inputBlock-btn--minus" onClick={handlerMinusPriceProductBtn}>
                                                            <img src="/images/sectionProductItemPage/Minus.png" alt="" className="cartBlock__inputBlock-btnImg" />
                                                        </button>

                                                        {/* указываем step этому инпуту со значением 0.01,чтобы можно было вводить дробные числа(нужно указывать запятую(,) в этом инпуте,чтобы указать дробное число),и минимальный шаг изменения числа в этом инпуте был 0.01(то есть при изменении стрелочками,минимально изменялось число на 0.01) */}
                                                        <input type="number" className="cartBlock__inputBlock-input" value={inputPriceValue} onChange={changeInputPriceValue} step={0.01} />

                                                        <button type="button" className="cartBlock__inputBlock-btn cartBlock__inputBlock-btn--plus" onClick={handlerPlusPriceProductBtn}>
                                                            <img src="/images/sectionProductItemPage/Plus.png" alt="" className="cartBlock__inputBlock-btnImg" />
                                                        </button>
                                                    </div>
                                                </div>

                                                <div className="adminForm__itemPrice-inputBlock">
                                                    <p className="sectionUserPage__formInfo-itemText">Price with Discount</p>
                                                    <div className="sectionProductItemPage__cartBlock-inputBlock sectionUserPage__adminForm-inputBlockDiscount">
                                                        {/* указываем этой кнопке тип button(type="button"),чтобы при нажатии на нее не отправлялась эта форма(для создания нового товара),указываем тип submit только одной кнопке формы,по которой она должна отправляться(то есть при нажатии на которую должен идти запрос на сервер для создания нового товара),всем остальным кнопкам формы указываем тип button */}
                                                        <button type="button" className="cartBlock__inputBlock-btn cartBlock__inputBlock-btn--minus" onClick={handlerMinusPriceDiscountProductBtn}>
                                                            <img src="/images/sectionProductItemPage/Minus.png" alt="" className="cartBlock__inputBlock-btnImg" />
                                                        </button>

                                                        {/* указываем step этому инпуту со значением 0.01,чтобы можно было вводить дробные числа(нужно указывать запятую(,) в этом инпуте,чтобы указать дробное число),и минимальный шаг изменения числа в этом инпуте был 0.01(то есть при изменении стрелочками,минимально изменялось число на 0.01) */}
                                                        <input type="number" className="cartBlock__inputBlock-input" value={inputPriceDiscountValue} onChange={changeInputPriceDiscountValue} step={0.01} />

                                                        <button type="button" className="cartBlock__inputBlock-btn cartBlock__inputBlock-btn--plus" onClick={handlerPlusPriceDiscountProductBtn}>
                                                            <img src="/images/sectionProductItemPage/Plus.png" alt="" className="cartBlock__inputBlock-btnImg" />
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="sectionUserPage__formInfo-item sectionUserPage__adminFormInfo-item">

                                                {/* указываем здесь проверку,если inputFileMainImage true(то есть в этом состоянии что-то есть,то есть пользователь добавил файл главной картинки),то показываем 1,в другом случае показываем 0 */}
                                                <p className="sectionUserPage__formInfo-itemText">Main Image {inputFileMainImage ? 1 : 0} / 1</p>

                                                {/* если imgPath не равно пустой строке,то показываем картинку */}
                                                {imgPath !== '' &&
                                                    <div className="adminForm__item-imageBlock adminForm__imageBlock-mainImageBlcok">

                                                        {/* в onClick этой button передаем в нашу функцию deleteMainImageRequestByBtn название файла,который пользователь выбрал в инпуте файлов(мы поместили его в состояние inputFileMainImage),наша функция deleteMainImageRequestByBtn делает запрос на сервер на удаление файла картинки и возвращает ответ от сервера(в данном случае при успешном запросе ответ от сервера будет объект с полями) */}
                                                        <button className="adminForm__item-imageBlockBtn" type="button" onClick={() => deleteMainImageRequestByBtn(inputFileMainImage?.name)} >
                                                            <img src="/images/sectionUserPage/CrossImg.png" alt="" className="adminForm__imageBlockBtn-img" />
                                                        </button>

                                                        <img src={imgPath} alt="" className="adminForm__item-imageBlockImg" />

                                                        {/* указываем название файла у состояния inputFileMainImage у поля name,указываем здесь ? перед name,так как иначе ошибка,что состояние inputFileMainImage может быть undefined */}
                                                        <p className="adminForm__item-imageBlockText">{inputFileMainImage?.name}</p>
                                                    </div>
                                                }

                                                <label htmlFor="inputFileMainImage" className="adminForm__item-imageBlockLabel">
                                                    Load Image

                                                    {/* указываем multiple этому инпуту для файлов,чтобы можно было выбирать несколько файлов одновременно для загрузки(в данном случае убрали multiple,чтобы был только 1 файл),указываем accept = "image/*",чтобы можно было выбирать только изображения любого типа,указываем этому инпуту ref как наш ref inputMainImage,указываем это,чтобы потом при удалении выбранной картинки очищать значение этого инпута,иначе,если выбрать картинку,потом ее удалить,а потом опять выбрать сразу же эту картинку в этом инпуте файлов,то она не будет выбираться,так как не будет срабатывать onChange для этого инпута,так как в этом инпуте будет еще сохранено предыдущее значение этого файла картинки */}
                                                    <input id="inputFileMainImage" type="file" className="adminForm__imageBlockLabel-inputImage" accept="image/*" ref={inputMainImage} onChange={inputLoadMainImageHandler} />

                                                </label>

                                            </div>

                                            <div className="sectionUserPage__formInfo-item sectionUserPage__adminFormInfo-item">

                                                {/* указываем здесь текущее значение длины массива descImages и максимально допустимое число картинок */}
                                                <p className="sectionUserPage__formInfo-itemText">Description Images {descImages.length} / 3</p>

                                                {/* если descImages.length true,то есть длина массива descImage есть,то есть этот массив не пустой,то показываем картинки,в другом случае пустая строка,то есть ничего не показываем,делаем эту проверку именно таким образом с помощью знака вопроса,иначе,если массив пустой,то будет показываться 0 */}
                                                {descImages.length ?

                                                    <div className="adminForm__descImagesBlock">

                                                        {/* пробегаемся по массиву descImages с помощью map,и отрисовываем картинки */}
                                                        {descImages.map(image =>

                                                            // указываем в key имя картинки,оно будет уникальным,так как мы проверяем на бэкэнде,чтобы не было одинаковых файлов
                                                            <div className="adminForm__item-imageBlock adminForm__imageBlock-mainImageBlcok" key={image.name}>

                                                                {/* в onClick этой button передаем в нашу функцию deleteDescImageRequestByBtn название файла,который пользователь выбрал в инпуте файлов(image.name, то есть имя текущего итерируемого объекта картинки в массиве descImages),наша функция deleteMainImageRequestByBtn делает запрос на сервер на удаление файла картинки и возвращает ответ от сервера(в данном случае при успешном запросе ответ от сервера будет объект с полями) */}
                                                                <button className="adminForm__item-imageBlockBtn" type="button" onClick={() => deleteDescImageRequestByBtn(image.name)} >
                                                                    <img src="/images/sectionUserPage/CrossImg.png" alt="" className="adminForm__imageBlockBtn-img" />
                                                                </button>

                                                                {/* указываем ref этой картинке как imageDescRef,этот ref будет меняться для каждой последней картинки,которую пользователь выбрал последней в инпуте файлов,то есть этот ref будет для картинки,которая последняя добавленная в массив descImages,поэтому не надо тут создавать несколько useRef */}
                                                                <img src={image.url} alt="" className="adminForm__item-imageBlockImg" />

                                                                {/* указываем название файла у картинки(image.name, то есть имя текущего итерируемого объекта картинки в массиве descImages) */}
                                                                <p className="adminForm__item-imageBlockText">{image.name}</p>
                                                            </div>

                                                        )}

                                                    </div>
                                                    : ''

                                                }

                                                {/* указываем тут другой id для инпута в htmlFor,чтобы не путался этот лейбл(label) с лейблом для инпута главной картинки,иначе вместо этого может срабатывать лейбл для инпута главной картинки */}
                                                <label htmlFor="inputFileDescImages" className="adminForm__item-imageBlockLabel">
                                                    Load Image

                                                    {/* указываем multiple этому инпуту для файлов,чтобы можно было выбирать несколько файлов одновременно для загрузки(в данном случае убрали multiple,чтобы был только 1 файл),указываем accept = "image/*",чтобы можно было выбирать только изображения любого типа,указываем этому инпуту ref как наш ref inputDescImages,указываем это,чтобы потом при удалении выбранной картинки очищать значение этого инпута,иначе,если выбрать картинку,потом ее удалить,а потом опять выбрать сразу же эту картинку в этом инпуте файлов,то она не будет выбираться,так как не будет срабатывать onChange для этого инпута,так как в этом инпуте будет еще сохранено предыдущее значение этого файла картинки  */}
                                                    <input id="inputFileDescImages" type="file" className="adminForm__imageBlockLabel-inputImage" accept="image/*" ref={inputDescImages} onChange={inputLoadDescImagesHandler} />

                                                </label>

                                            </div>

                                            {/* если errorNewProductForm true(то есть в состоянии errorNewProductForm что-то есть),то показываем текст ошибки */}
                                            {errorNewProductForm && <p className="formErrorText">{errorNewProductForm}</p>}

                                            {/* если errorNewProductFormForImg true(то есть в состоянии errorNewProductFormForImg(состояние для ошибки картинки для формы админа) что-то есть),то показываем текст ошибки */}
                                            {errorNewProductFormForImg && <p className="formErrorText">{errorNewProductFormForImg}</p>}

                                            {/* указываем этой кнопке тип submit,чтобы при нажатии на нее сработало событие onSubmit у этой формы */}
                                            <button className="signInForm__btn sectionUserPage__formInfo-btn" type="submit">Save Product</button>

                                        </div>
                                    </form>

                                </div>
                            }

                        </div>
                    </div>
                </div>
            </section>

        </main>
    )

}

export default UserPage;